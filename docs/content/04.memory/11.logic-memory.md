---
title: Logic Memory
description: 用户偏好和行为模式的自动学习与记忆框架
---

# Logic Memory

Logic Memory 是 Aster SDK 的第四种 Memory 类型，专门用于存储和管理用户偏好、行为模式和学习到的规则。与其他 Memory 类型不同，Logic Memory 专注于从用户交互中自动学习，并在后续交互中应用这些学习成果。

## 概述

### 与其他 Memory 类型的对比

| 特性 | Text Memory | Working Memory | Semantic Memory | **Logic Memory** |
|------|-------------|----------------|-----------------|------------------|
| **用途** | 长期知识存储 | 临时状态管理 | 语义检索 | **用户偏好和行为模式** |
| **格式** | Markdown 文件 | JSON Schema | 向量 + Metadata | **结构化对象** |
| **检索** | 文件路径/Grep | Key-Value | 向量相似度 | **类型/作用域/置信度** |
| **作用域** | Namespace | Thread/Resource | Namespace | **Session/User/Global** |
| **典型场景** | agent.md, 文档 | 对话上下文 | RAG, 素材检索 | **风格偏好、修改习惯** |

### 核心价值

Logic Memory 让 AI Agent 能够：
- **记住用户偏好**：语气、风格、格式等个性化设置
- **学习行为模式**：从用户修改中识别规律
- **自动改进**：基于反馈调整生成策略
- **跨会话持久化**：学习成果在多次交互中保持

## 快速开始

### 基础配置

```go
package main

import (
    "github.com/astercloud/aster/pkg/memory/logic"
    "github.com/astercloud/aster/pkg/middleware"
)

func main() {
    // 1. 创建存储后端
    store := logic.NewInMemoryStore() // 或 NewPostgreSQLStore(db)

    // 2. 创建 Manager
    manager, err := logic.NewManager(&logic.ManagerConfig{
        Store: store,
    })
    if err != nil {
        panic(err)
    }

    // 3. 配置 Middleware
    mw := middleware.NewLogicMemoryMiddleware(&middleware.LogicMemoryConfig{
        Manager:         manager,
        EnableCapture:   true,
        EnableInjection: true,
        MaxMemories:     5,
        MinConfidence:   0.6,
    })

    // 4. 注册到 Agent
    // deps.MiddlewareStack.Add(mw)
}
```

### 手动记录 Memory

```go
ctx := context.Background()

mem := &logic.LogicMemory{
    Namespace:   "user:123",
    Scope:       logic.ScopeUser,
    Type:        "preference",
    Key:         "writing_tone",
    Value:       "casual",
    Description: "用户偏好口语化的写作风格",
    Provenance: &memory.MemoryProvenance{
        SourceType: memory.SourceUserInput,
        Confidence: 0.8,
    },
}

err := manager.RecordMemory(ctx, mem)
```

### 检索 Memory

```go
// 检索所有 Memory
memories, err := manager.RetrieveMemories(ctx, "user:123")

// 带过滤条件
memories, err := manager.RetrieveMemories(ctx, "user:123",
    logic.WithTopK(5),           // 最多返回 5 条
    logic.WithMinConfidence(0.7), // 最低置信度 0.7
    logic.WithType("preference"), // 只返回偏好类型
)
```

## 核心概念

### Memory 作用域 (Scope)

Logic Memory 支持三种作用域：

```go
const (
    ScopeSession  MemoryScope = "session"  // 单次会话，会话结束后失效
    ScopeUser     MemoryScope = "user"     // 用户级别，跨会话持久化
    ScopeGlobal   MemoryScope = "global"   // 全局，跨用户共享
)
```

### Memory 类型 (Type)

Type 字段用于分类 Memory，常见类型包括：

- `preference` - 用户偏好（语气、风格、格式）
- `behavior` - 行为模式（操作习惯、使用频率）
- `rule` - 学习到的规则（约束、规范）
- `feedback` - 用户反馈（评价、修正）

### 置信度 (Confidence)

每个 Memory 都有一个置信度分数（0.0-1.0）：

- **0.0-0.5**：低置信度，可能是噪声
- **0.5-0.7**：中等置信度，需要更多验证
- **0.7-0.9**：高置信度，可以应用
- **0.9-1.0**：非常高置信度，强烈推荐应用

置信度会随着：
- **重复出现** 而提升（每次 +5%）
- **用户确认** 而大幅提升
- **长期未访问** 而逐渐衰减

## 模式匹配器 (PatternMatcher)

PatternMatcher 是 Logic Memory 的核心扩展点，用于从事件中自动识别和提取 Memory。

### 接口定义

```go
type PatternMatcher interface {
    // 从事件中识别 Memory
    MatchEvent(ctx context.Context, event Event) ([]*LogicMemory, error)

    // 支持的事件类型
    SupportedEventTypes() []string
}
```

### 自定义实现示例

```go
type WritingPatternMatcher struct{}

func (m *WritingPatternMatcher) SupportedEventTypes() []string {
    return []string{"user_revision", "user_feedback"}
}

func (m *WritingPatternMatcher) MatchEvent(ctx context.Context, event Event) ([]*LogicMemory, error) {
    switch event.Type {
    case "user_revision":
        return m.matchRevision(event)
    case "user_feedback":
        return m.matchFeedback(event)
    }
    return nil, nil
}

func (m *WritingPatternMatcher) matchRevision(event Event) ([]*LogicMemory, error) {
    original := event.Data["original"].(string)
    revised := event.Data["revised"].(string)

    var memories []*LogicMemory

    // 示例：检测是否删除了正式用语
    if containsFormalWords(original) && !containsFormalWords(revised) {
        memories = append(memories, &LogicMemory{
            Namespace:   event.Source,
            Scope:       ScopeUser,
            Type:        "preference",
            Key:         "casual_tone",
            Value:       true,
            Description: "用户偏好口语化表达，避免使用书面语",
            Provenance: &memory.MemoryProvenance{
                SourceType: memory.SourceUserInput,
                Confidence: 0.7,
            },
        })
    }

    return memories, nil
}
```

### 注册 PatternMatcher

```go
manager, err := logic.NewManager(&logic.ManagerConfig{
    Store: store,
    Matchers: []logic.PatternMatcher{
        &WritingPatternMatcher{},
        &BehaviorPatternMatcher{},
    },
})
```

## 事件处理

### 事件结构

```go
type Event struct {
    Type      string         // 事件类型
    Source    string         // 来源（user_id, agent_id）
    Data      map[string]any // 事件数据
    Timestamp time.Time      // 时间戳
}
```

### 常见事件类型

| 事件类型 | 描述 | 典型数据 |
|---------|------|----------|
| `user_message` | 用户发送消息 | `{content, intent}` |
| `user_revision` | 用户修改内容 | `{original, revised}` |
| `user_feedback` | 用户评价 | `{rating, comment}` |
| `tool_result` | 工具执行结果 | `{tool, success, output}` |
| `agent_response` | Agent 响应 | `{content, tokens}` |

### 手动触发事件

```go
event := logic.Event{
    Type:   "user_revision",
    Source: "user:123",
    Data: map[string]any{
        "original": "然而，这个方法有几个缺点...",
        "revised":  "不过，这个方法有几个问题...",
    },
    Timestamp: time.Now(),
}

err := manager.ProcessEvent(ctx, event)
```

## Memory 合并 (Consolidation)

当多个相似的 Memory 存在时，ConsolidationEngine 会自动合并它们。

### 配置

```go
engine := logic.NewConsolidationEngine(&logic.ConsolidationConfig{
    SimilarityThreshold: 0.85,  // 相似度阈值
    MergeStrategy:       logic.MergeStrategyKeepNewest,
})

result, err := engine.Consolidate(ctx, memories)
```

### 合并策略

```go
const (
    MergeStrategyKeepNewest          = "keep_newest"           // 保留最新
    MergeStrategyKeepHighestConfidence = "keep_highest_confidence" // 保留最高置信度
    MergeStrategyMergeDescriptions   = "merge_descriptions"    // 合并描述
)
```

## Memory 清理 (Pruning)

定期清理低价值的 Memory 以保持系统性能。

### 清理条件

```go
criteria := logic.PruneCriteria{
    MinConfidence:   0.3,              // 置信度低于 0.3
    SinceLastAccess: 30 * 24 * time.Hour, // 30 天未访问
    MinAccessCount:  2,                // 访问次数少于 2
    MaxAge:          90 * 24 * time.Hour, // 创建超过 90 天
}

count, err := manager.PruneMemories(ctx, criteria)
```

## 存储后端

### InMemory（测试用）

```go
store := logic.NewInMemoryStore()
```

### PostgreSQL

```go
import "database/sql"

db, _ := sql.Open("postgres", "postgres://...")
store, err := logic.NewPostgreSQLStore(db, &logic.PostgreSQLStoreConfig{
    TableName:     "logic_memories",
    AutoMigrate:   true,
})
```

### MySQL

```go
db, _ := sql.Open("mysql", "user:pass@tcp(localhost:3306)/db")
store, err := logic.NewMySQLStore(db, &logic.MySQLStoreConfig{
    TableName:     "logic_memories",
    AutoMigrate:   true,
})
```

## Middleware 集成

LogicMemoryMiddleware 提供自动捕获和注入功能。

### 完整配置

```go
mw := middleware.NewLogicMemoryMiddleware(&middleware.LogicMemoryConfig{
    Manager: manager,

    // 捕获配置
    EnableCapture:   true,
    CaptureChannels: []types.AgentChannel{
        types.ChannelControl,
        types.ChannelMonitor,
    },
    AsyncCapture:    true,  // 异步捕获，不阻塞主流程

    // 注入配置
    EnableInjection: true,
    InjectionPoint:  "system_prompt",
    MaxMemories:     5,
    MinConfidence:   0.6,

    // 性能配置
    CacheTTL: time.Hour,
})
```

### 自定义 Prompt 模板

```go
config.SystemPromptTemplate = `
## User Preferences

Based on past interactions, the following preferences have been learned:

%s

Please apply these preferences naturally without explicitly mentioning them.
`
```

## 监控指标

Logic Memory 提供 Prometheus 兼容的监控指标。

### 可用指标

| 指标名 | 类型 | 描述 |
|-------|------|------|
| `logic_memory_save_total` | Counter | 保存操作总数 |
| `logic_memory_save_errors_total` | Counter | 保存错误数 |
| `logic_memory_get_total` | Counter | 获取操作总数 |
| `logic_memory_event_process_total` | Counter | 事件处理总数 |
| `logic_memory_total` | Gauge | Memory 总数（按 namespace） |
| `logic_memory_save_duration_seconds` | Histogram | 保存耗时 |

### 导出到 Prometheus

```go
metrics := logic.NewMetrics()

// 记录操作
metrics.RecordSave("user:123", "preference", logic.ScopeUser, duration, nil)
metrics.RecordGet(duration, nil)
metrics.RecordEventProcess("user_revision", duration, nil)

// 导出
metrics.ExportToPrometheus(prometheusExporter)
```

## 工具集成

Logic Memory 提供两个内置工具供 Agent 使用。

### LogicMemoryQueryTool

允许 Agent 查询 Memory：

```json
{
  "name": "logic_memory_query",
  "input": {
    "action": "list",
    "type": "preference",
    "top_k": 5
  }
}
```

支持的 action：
- `list` - 列出所有 Memory
- `get` - 获取指定 Memory
- `search` - 搜索 Memory
- `stats` - 获取统计信息

### LogicMemoryUpdateTool

允许 Agent 更新 Memory：

```json
{
  "name": "logic_memory_update",
  "input": {
    "action": "record",
    "type": "preference",
    "key": "format_preference",
    "value": {"bullet_points": true},
    "description": "用户偏好使用列表格式"
  }
}
```

## 最佳实践

### 1. 合理设置置信度阈值

```go
// 对于重要决策，使用较高阈值
memories, _ := manager.RetrieveMemories(ctx, namespace,
    logic.WithMinConfidence(0.8),
)

// 对于建议性内容，可以使用较低阈值
memories, _ := manager.RetrieveMemories(ctx, namespace,
    logic.WithMinConfidence(0.5),
)
```

### 2. 按类型分类 Memory

```go
// 使用清晰的类型命名
const (
    TypePreference = "preference"  // 用户偏好
    TypeBehavior   = "behavior"    // 行为模式
    TypeRule       = "rule"        // 规则约束
    TypeContext    = "context"     // 上下文信息
)
```

### 3. 定期执行清理

```go
// 每天执行一次清理
go func() {
    ticker := time.NewTicker(24 * time.Hour)
    for range ticker.C {
        criteria := logic.PruneCriteria{
            MinConfidence:   0.3,
            SinceLastAccess: 30 * 24 * time.Hour,
        }
        manager.PruneMemories(context.Background(), criteria)
    }
}()
```

### 4. 异步捕获以避免阻塞

```go
config := &middleware.LogicMemoryConfig{
    AsyncCapture:     true,
    CaptureBufferSize: 100,  // 缓冲区大小
}
```

## 故障排除

### Memory 未被捕获

1. 确认 `EnableCapture` 为 `true`
2. 检查 PatternMatcher 是否正确注册
3. 验证 PatternMatcher 的 `SupportedEventTypes()` 包含对应事件类型

### Memory 未被注入

1. 确认 `EnableInjection` 为 `true`
2. 检查 `MinConfidence` 是否设置过高
3. 验证 Memory 的 Namespace 与当前上下文匹配

### 性能问题

1. 启用异步捕获：`AsyncCapture: true`
2. 设置缓存：`CacheTTL: time.Hour`
3. 限制返回数量：`MaxMemories: 5`
4. 优化数据库索引

## API 参考

详细的 API 文档请参考：

- [LogicMemory 类型](/api-reference/memory/logic-memory)
- [LogicMemoryStore 接口](/api-reference/memory/logic-store)
- [PatternMatcher 接口](/api-reference/memory/pattern-matcher)
- [LogicMemoryMiddleware](/api-reference/middleware/logic-memory)
