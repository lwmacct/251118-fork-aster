---
title: Logic Memory è®¾è®¡ä¸å®æ–½è®¡åˆ’
description: Aster Logic Memoryï¼ˆç¬¬å››ç±»è®°å¿†ï¼‰çš„æ¶æ„ã€å®æ–½è·¯çº¿ä¸éªŒæ”¶æ ‡å‡†
---

# Aster SDK Logic Memory é€šç”¨æ¡†æ¶è®¾è®¡ä¸å®æ–½è®¡åˆ’

## æ‰§è¡Œæ‘˜è¦

åœ¨ **Aster Agent SDK æ¡†æ¶å±‚** å®ç°é€šç”¨çš„ Logic Memory ç³»ç»Ÿï¼Œä½œä¸ºç¬¬å››ç§ Memory ç±»å‹ï¼ˆä¸ Text/Working/Semantic Memory å¹¶åˆ—ï¼‰ã€‚æä¾›å¼€ç®±å³ç”¨çš„ç”¨æˆ·åå¥½å­¦ä¹ å’Œè¡Œä¸ºæ¨¡å¼è®°å¿†èƒ½åŠ›ï¼Œæ”¯æŒä»»æ„åº”ç”¨åœºæ™¯ï¼ˆåˆ›ä½œã€å¯¹è¯ã€ç¼–ç¨‹ã€å®¢æœç­‰ï¼‰ã€‚

**è®¾è®¡åŸåˆ™**ï¼š
- **é€šç”¨æ€§ä¼˜å…ˆ**ï¼šæ¡†æ¶å±‚æä¾›é€šç”¨æœºåˆ¶ï¼Œåº”ç”¨å±‚å®šä¹‰ä¸šåŠ¡é€»è¾‘
- **æœ€å°ä¾µå…¥**ï¼šé€šè¿‡ Middleware è‡ªåŠ¨æ•è·ï¼Œæ— éœ€åº”ç”¨å±‚æ‰‹åŠ¨è°ƒç”¨
- **å¯æ‰©å±•æ€§**ï¼šæ”¯æŒè‡ªå®šä¹‰ Memory ç±»å‹ã€Pattern Matcherã€Storage Backend
- **ç”Ÿäº§å°±ç»ª**ï¼šå®Œæ•´çš„ç›‘æ§ã€æµ‹è¯•ã€æ–‡æ¡£

**å‚è€ƒæ¡ˆä¾‹**ï¼šYunJin å†™ä½œå¹³å°ï¼ˆéªŒè¯æ¡†æ¶çš„å®é™…å¯ç”¨æ€§ï¼‰

---

## ä¸€ã€æ¶æ„è®¾è®¡

### 1.1 æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Aster Agent SDK                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                  Memory System                           â”‚   â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚  â”‚  Text Memory  â”‚ Working Memory â”‚ Semantic Memory â”‚ NEW  â”‚   â”‚
â”‚  â”‚  (agent.md)   â”‚ (ä¸´æ—¶çŠ¶æ€)      â”‚ (å‘é‡æ£€ç´¢)      â”‚ Logicâ”‚   â”‚
â”‚  â”‚               â”‚                 â”‚                 â”‚Memoryâ”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚              Logic Memory Framework                      â”‚   â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚  â”‚                                                           â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”‚
â”‚  â”‚  â”‚  Capture     â”‚  â”‚   Storage    â”‚  â”‚  Retrieval   â”‚  â”‚   â”‚
â”‚  â”‚  â”‚  æ•è·å±‚      â”‚  â”‚   å­˜å‚¨å±‚     â”‚  â”‚  æ£€ç´¢å±‚      â”‚  â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
â”‚  â”‚         â”‚                  â”‚                  â”‚         â”‚   â”‚
â”‚  â”‚         â–¼                  â–¼                  â–¼         â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”‚
â”‚  â”‚  â”‚         Logic Memory Manager (æ ¸å¿ƒ)            â”‚  â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
â”‚  â”‚                                                           â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚            Middleware Stack                              â”‚   â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚  â”‚  LogicMemoryMiddleware (NEW)                            â”‚   â”‚
â”‚  â”‚  - è®¢é˜… EventBus                                         â”‚   â”‚
â”‚  â”‚  - è‡ªåŠ¨æ•è·ç”¨æˆ·äº¤äº’                                      â”‚   â”‚
â”‚  â”‚  - æ³¨å…¥ Memory åˆ° System Prompt                          â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

          â–²                                     â–²
          â”‚                                     â”‚
          â”‚  åº”ç”¨å±‚è‡ªå®šä¹‰                       â”‚  åº”ç”¨å±‚è°ƒç”¨
          â”‚  (MemoryType, PatternMatcher)      â”‚  (åˆå§‹åŒ–é…ç½®)
          â”‚                                     â”‚

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Application Layer                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  - å®šä¹‰ä¸šåŠ¡ç›¸å…³çš„ Memory ç±»å‹ (WritingPreference, etc.)         â”‚
â”‚  - å®ç°è‡ªå®šä¹‰ PatternMatcher (è¯†åˆ«ç”¨æˆ·ä¿®æ”¹æ¨¡å¼)                 â”‚
â”‚  - é…ç½® LogicMemoryMiddleware                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 æ ¸å¿ƒç»„ä»¶è®¾è®¡

#### ç»„ä»¶ 1: LogicMemory - æ ¸å¿ƒæ•°æ®ç»“æ„

```go
// pkg/memory/logic/types.go

// LogicMemory é€»è¾‘è®°å¿†ï¼ˆé€šç”¨ç»“æ„ï¼‰
type LogicMemory struct {
    // åŸºç¡€å­—æ®µ
    ID            string
    Namespace     string  // ç§Ÿæˆ·éš”ç¦»ï¼ˆuser:123, team:456, globalï¼‰
    Scope         MemoryScope  // Session/User/Global

    // Memory ç±»å‹ï¼ˆåº”ç”¨å±‚å®šä¹‰ï¼‰
    Type          string  // "user_preference", "behavior_pattern", etc.
    Category      string  // åˆ†ç±»ï¼ˆå¯é€‰ï¼‰

    // Memory å†…å®¹
    Key           string  // å”¯ä¸€æ ‡è¯†ï¼ˆå¦‚ "writing_tone_preference"ï¼‰
    Value         any     // å€¼ï¼ˆç»“æ„åŒ–æ•°æ®ï¼‰
    Description   string  // äººç±»å¯è¯»æè¿°ï¼ˆç”¨äº Prompt æ³¨å…¥ï¼‰

    // æº¯æºï¼ˆå¤ç”¨ç°æœ‰ Provenanceï¼‰
    Provenance    *MemoryProvenance

    // ç»Ÿè®¡
    AccessCount   int
    LastAccessed  time.Time

    // å…ƒä¿¡æ¯
    Metadata      map[string]any  // æ‰©å±•å­—æ®µ
    CreatedAt     time.Time
    UpdatedAt     time.Time
}

// MemoryScope è®°å¿†ä½œç”¨åŸŸ
type MemoryScope string

const (
    ScopeSession  MemoryScope = "session"  // å•æ¬¡ä¼šè¯
    ScopeUser     MemoryScope = "user"     // ç”¨æˆ·çº§åˆ«
    ScopeGlobal   MemoryScope = "global"   // å…¨å±€ï¼ˆè·¨ç”¨æˆ·ï¼‰
)
```

#### ç»„ä»¶ 2: LogicMemoryStore - å­˜å‚¨æ¥å£ï¼ˆå¯æ‰©å±•ï¼‰

```go
// pkg/memory/logic/store.go

// LogicMemoryStore å­˜å‚¨æ¥å£ï¼ˆç±»ä¼¼ç°æœ‰ BackendProtocolï¼‰
type LogicMemoryStore interface {
    // åŸºç¡€ CRUD
    Save(ctx context.Context, memory *LogicMemory) error
    Get(ctx context.Context, namespace, key string) (*LogicMemory, error)
    Delete(ctx context.Context, namespace, key string) error
    List(ctx context.Context, namespace string, filters ...Filter) ([]*LogicMemory, error)

    // é«˜çº§æŸ¥è¯¢
    SearchByType(ctx context.Context, namespace, memoryType string) ([]*LogicMemory, error)
    SearchByScope(ctx context.Context, namespace string, scope MemoryScope) ([]*LogicMemory, error)
    GetTopK(ctx context.Context, namespace string, k int, orderBy OrderBy) ([]*LogicMemory, error)

    // ç»Ÿè®¡
    IncrementAccessCount(ctx context.Context, namespace, key string) error
    GetStats(ctx context.Context, namespace string) (*MemoryStats, error)

    // ç”Ÿå‘½å‘¨æœŸ
    Prune(ctx context.Context, criteria PruneCriteria) (int, error)  // æ¸…ç†ä½ä»·å€¼ Memory
}

// å†…ç½®å®ç°
type PostgreSQLLogicStore struct { /* åŸºäº PostgreSQL */ }
type RedisLogicStore struct { /* åŸºäº Redisï¼ˆç®€å•åœºæ™¯ï¼‰ */ }
type InMemoryLogicStore struct { /* åŸºäºå†…å­˜ï¼ˆæµ‹è¯•ç”¨ï¼‰ */ }
```

#### ç»„ä»¶ 3: PatternMatcher - æ¨¡å¼è¯†åˆ«ï¼ˆå¯æ‰©å±•ï¼‰

```go
// pkg/memory/logic/matcher.go

// PatternMatcher æ¨¡å¼è¯†åˆ«æ¥å£ï¼ˆåº”ç”¨å±‚å®ç°ï¼‰
type PatternMatcher interface {
    // ä»äº‹ä»¶ä¸­è¯†åˆ« Memory
    MatchEvent(ctx context.Context, event Event) ([]*LogicMemory, error)

    // æ”¯æŒçš„äº‹ä»¶ç±»å‹
    SupportedEventTypes() []string
}

// Event é€šç”¨äº‹ä»¶ç»“æ„
type Event struct {
    Type      string         // "user_message", "tool_result", "user_feedback", etc.
    Source    string         // æ¥æºï¼ˆagent_id, user_idï¼‰
    Data      map[string]any // äº‹ä»¶æ•°æ®
    Timestamp time.Time
}

// åº”ç”¨å±‚ç¤ºä¾‹ï¼šYunJin çš„ PatternMatcher
type YunJinPatternMatcher struct {
    // è‡ªå®šä¹‰è¯†åˆ«é€»è¾‘
}

func (m *YunJinPatternMatcher) MatchEvent(ctx context.Context, event Event) ([]*LogicMemory, error) {
    switch event.Type {
    case "user_revision":
        return m.matchRevisionPattern(event.Data)
    case "user_feedback":
        return m.matchFeedbackPattern(event.Data)
    default:
        return nil, nil
    }
}
```

#### ç»„ä»¶ 4: LogicMemoryManager - æ ¸å¿ƒç®¡ç†å™¨

```go
// pkg/memory/logic/manager.go

// LogicMemoryManager æ ¸å¿ƒç®¡ç†å™¨
type LogicMemoryManager struct {
    store           LogicMemoryStore
    matchers        []PatternMatcher  // æ”¯æŒå¤šä¸ª Matcher
    provenance      *MemoryProvenance
    consolidation   *ConsolidationEngine  // å¤ç”¨ç°æœ‰ Consolidation
    confidence      *ConfidenceCalculator // å¤ç”¨ç°æœ‰ Confidence
}

// RecordMemory è®°å½•æ–° Memoryï¼ˆä¸»åŠ¨è°ƒç”¨ï¼‰
func (m *LogicMemoryManager) RecordMemory(ctx context.Context, memory *LogicMemory) error

// ProcessEvent å¤„ç†äº‹ä»¶ï¼Œè‡ªåŠ¨è¯†åˆ«å’Œè®°å½• Memoryï¼ˆè¢«åŠ¨è§¦å‘ï¼‰
func (m *LogicMemoryManager) ProcessEvent(ctx context.Context, event Event) error

// RetrieveMemories æ£€ç´¢ Memoryï¼ˆç”¨äº Prompt æ³¨å…¥ï¼‰
func (m *LogicMemoryManager) RetrieveMemories(
    ctx context.Context,
    namespace string,
    filters ...Filter,
) ([]*LogicMemory, error)

// ConsolidateMemories åˆå¹¶å†—ä½™ Memoryï¼ˆå®šæœŸä»»åŠ¡ï¼‰
func (m *LogicMemoryManager) ConsolidateMemories(ctx context.Context, namespace string) error

// PruneMemories æ¸…ç†ä½ä»·å€¼ Memoryï¼ˆå®šæœŸä»»åŠ¡ï¼‰
func (m *LogicMemoryManager) PruneMemories(ctx context.Context, criteria PruneCriteria) error
```

#### ç»„ä»¶ 5: LogicMemoryMiddleware - è‡ªåŠ¨æ•è·å’Œæ³¨å…¥

```go
// pkg/middleware/logic_memory.go

// LogicMemoryMiddleware Logic Memory ä¸­é—´ä»¶
type LogicMemoryMiddleware struct {
    *BaseMiddleware
    manager      *logic.LogicMemoryManager
    eventBus     *events.EventBus
    config       *LogicMemoryConfig
}

// LogicMemoryConfig é…ç½®
type LogicMemoryConfig struct {
    // å­˜å‚¨é…ç½®
    Store            logic.LogicMemoryStore
    Matchers         []logic.PatternMatcher  // åº”ç”¨å±‚æ³¨å…¥

    // æ•è·é…ç½®
    EnableCapture    bool
    CaptureChannels  []types.AgentChannel  // Progress/Control/Monitor

    // æ³¨å…¥é…ç½®
    EnableInjection  bool
    InjectionPoint   string  // "system_prompt", "user_prompt", "both"
    MaxMemories      int     // TopK
    MinConfidence    float64 // æœ€ä½ç½®ä¿¡åº¦

    // æ€§èƒ½é…ç½®
    AsyncCapture     bool
    CacheTTL         time.Duration
}

// OnAgentStart Agent å¯åŠ¨æ—¶è®¢é˜…äº‹ä»¶
func (m *LogicMemoryMiddleware) OnAgentStart(ctx context.Context, agentID string) error {
    // è®¢é˜… EventBus
    m.eventBus.OnControl("*", m.handleControlEvent)
    m.eventBus.OnMonitor("*", m.handleMonitorEvent)
    // ...
}

// WrapModelCall æ³¨å…¥ Memory åˆ° Prompt
func (m *LogicMemoryMiddleware) WrapModelCall(next ModelCallFunc) ModelCallFunc {
    return func(ctx context.Context, msgs []types.Message, cfg *types.CallConfig) (types.Message, error) {
        // 1. æ£€ç´¢ç›¸å…³ Memory
        namespace := getNamespaceFromContext(ctx)
        memories, _ := m.manager.RetrieveMemories(ctx, namespace,
            logic.WithTopK(m.config.MaxMemories),
            logic.WithMinConfidence(m.config.MinConfidence),
        )

        // 2. æ³¨å…¥åˆ° System Prompt
        if len(memories) > 0 {
            msgs = m.injectMemories(msgs, memories)
        }

        // 3. æ‰§è¡ŒåŸå§‹è°ƒç”¨
        return next(ctx, msgs, cfg)
    }
}

// handleControlEvent å¤„ç† Control äº‹ä»¶ï¼ˆç”¨æˆ·äº¤äº’ï¼‰
func (m *LogicMemoryMiddleware) handleControlEvent(event any) {
    // è½¬æ¢ä¸ºé€šç”¨ Event
    genericEvent := m.convertToGenericEvent(event)

    // å¼‚æ­¥å¤„ç†ï¼ˆä¸é˜»å¡ä¸»æµç¨‹ï¼‰
    if m.config.AsyncCapture {
        go m.processEventAsync(genericEvent)
    } else {
        m.manager.ProcessEvent(context.Background(), genericEvent)
    }
}
```

---

## äºŒã€ä¸ç°æœ‰ Memory ç³»ç»Ÿçš„å¯¹æ¯”å’Œé›†æˆ

### 2.1 å››ç§ Memory å¯¹æ¯”

| ç‰¹æ€§ | Text Memory | Working Memory | Semantic Memory | **Logic Memory (NEW)** |
|------|-------------|----------------|-----------------|----------------------|
| **ç”¨é€”** | é•¿æœŸçŸ¥è¯†å­˜å‚¨ | ä¸´æ—¶çŠ¶æ€ç®¡ç† | è¯­ä¹‰æ£€ç´¢ | **ç”¨æˆ·åå¥½å’Œè¡Œä¸ºæ¨¡å¼** |
| **æ ¼å¼** | Markdown æ–‡ä»¶ | JSON Schema | å‘é‡ + Metadata | **ç»“æ„åŒ–å¯¹è±¡** |
| **æ£€ç´¢** | æ–‡ä»¶è·¯å¾„/Grep | Key-Value | å‘é‡ç›¸ä¼¼åº¦ | **ç±»å‹/ä½œç”¨åŸŸ/ç½®ä¿¡åº¦** |
| **ä½œç”¨åŸŸ** | Namespace | Thread/Resource | Namespace | **Session/User/Global** |
| **å¯è¯»æ€§** | é«˜ï¼ˆäººç±»å¯ç¼–è¾‘ï¼‰ | ä¸­ï¼ˆJSONï¼‰ | ä½ï¼ˆå‘é‡ï¼‰ | **é«˜ï¼ˆDescription å­—æ®µï¼‰** |
| **å…¸å‹åœºæ™¯** | agent.md, æ–‡æ¡£ | å¯¹è¯ä¸Šä¸‹æ–‡ | RAG, ç´ ææ£€ç´¢ | **é£æ ¼åå¥½ã€ä¿®æ”¹ä¹ æƒ¯** |

### 2.2 é›†æˆç­–ç•¥

**Logic Memory ä¸ç°æœ‰ Memory çš„åä½œ**ï¼š

1. **ä¸ Text Memory åä½œ**ï¼š
   - Logic Memory è‡ªåŠ¨ç”Ÿæˆçš„é«˜ç½®ä¿¡åº¦æ¨¡å¼å¯å†™å…¥ `/memory/patterns.md`
   - ç”¨æˆ·å¯ç¼–è¾‘ Text Memory æ¥ä¿®æ­£ Logic Memory
2. **ä¸ Semantic Memory åä½œ**ï¼š
   - Logic Memory çš„ Description å­—æ®µå¯ç´¢å¼•åˆ° Semantic Memory
   - æ”¯æŒè¯­ä¹‰æ£€ç´¢ï¼ˆ"æ‰¾åˆ°å…³äºå†™ä½œé£æ ¼çš„ Memory"ï¼‰
3. **ä¸ Working Memory åä½œ**ï¼š
   - Session çº§åˆ«çš„ Logic Memory å¯è½¬æ¢ä¸º Working Memory
   - Working Memory çš„å˜åŒ–å¯è§¦å‘ Logic Memory æ›´æ–°

**ç¤ºä¾‹**ï¼š

```go
// åœ¨ Logic Memory Manager ä¸­é›†æˆç°æœ‰ Memory
type LogicMemoryManager struct {
    // ç°æœ‰ Memory ç³»ç»Ÿ
    textMemory     *memory.Manager
    semanticMemory *memory.SemanticMemory
    workingMemory  *memory.WorkingMemoryManager

    // Logic Memory ä¸“ç”¨
    logicStore     LogicMemoryStore
    matchers       []PatternMatcher
}

// è‡ªåŠ¨åŒæ­¥åˆ° Text Memory
func (m *LogicMemoryManager) RecordMemory(ctx context.Context, mem *LogicMemory) error {
    // 1. å­˜å‚¨åˆ° Logic Store
    err := m.logicStore.Save(ctx, mem)

    // 2. å¦‚æœç½®ä¿¡åº¦é«˜ï¼ŒåŒæ­¥åˆ° Text Memory
    if mem.Provenance.Confidence > 0.85 {
        markdown := m.formatAsMarkdown(mem)
        m.textMemory.AppendNote(ctx, "/memory/patterns.md", mem.Key, markdown)
    }

    // 3. ç´¢å¼•åˆ° Semantic Memory
    if mem.Description != "" {
        m.semanticMemory.Index(ctx, mem.ID, mem.Description, mem.Metadata())
    }

    return err
}
```

---

## ä¸‰ã€å®æ–½è®¡åˆ’ï¼ˆ3-4 å‘¨ï¼‰

### Week 1: æ ¸å¿ƒæ¡†æ¶ï¼ˆAster SDK å±‚ï¼‰

#### Day 1-2: æ•°æ®æ¨¡å‹å’Œå­˜å‚¨æ¥å£

**æ–°å»ºæ–‡ä»¶**ï¼š
- `pkg/memory/logic/types.go` - æ ¸å¿ƒæ•°æ®ç»“æ„
- `pkg/memory/logic/store.go` - å­˜å‚¨æ¥å£å®šä¹‰
- `pkg/memory/logic/store_postgres.go` - PostgreSQL å®ç°
- `pkg/memory/logic/store_inmemory.go` - å†…å­˜å®ç°ï¼ˆæµ‹è¯•ç”¨ï¼‰

**æ•°æ®åº“è¡¨è®¾è®¡**ï¼š

```sql
-- Aster SDK é€šç”¨è¡¨ï¼ˆåº”ç”¨å±‚å¯æ‰©å±•ï¼‰
CREATE TABLE logic_memories (
    id VARCHAR(64) PRIMARY KEY,
    namespace VARCHAR(255) NOT NULL,  -- user:123, team:456, global
    scope VARCHAR(20) NOT NULL,       -- session/user/global

    type VARCHAR(100) NOT NULL,
    category VARCHAR(100),
    key VARCHAR(255) NOT NULL,
    value JSONB NOT NULL,
    description TEXT,

    -- Provenance (å¤ç”¨ç°æœ‰ç»“æ„)
    source_type VARCHAR(50),
    confidence DECIMAL(3,2),
    sources JSONB,

    access_count INT DEFAULT 0,
    last_accessed TIMESTAMP,

    metadata JSONB,
    created_at TIMESTAMP NOT NULL,
    updated_at TIMESTAMP NOT NULL,

    UNIQUE INDEX idx_namespace_key (namespace, key),
    INDEX idx_namespace_type (namespace, type),
    INDEX idx_scope (scope),
    INDEX idx_confidence (confidence)
);
```

**éªŒæ”¶æ ‡å‡†**ï¼š
- [ ] LogicMemory æ•°æ®ç»“æ„å®šä¹‰å®Œæ•´
- [ ] LogicMemoryStore æ¥å£å®šä¹‰æ¸…æ™°
- [ ] PostgreSQL å®ç°å•å…ƒæµ‹è¯•é€šè¿‡
- [ ] InMemory å®ç°å¯ç”¨äºæµ‹è¯•

---

#### Day 3-4: PatternMatcher å’Œ Manager

**æ–°å»ºæ–‡ä»¶**ï¼š
- `pkg/memory/logic/matcher.go` - PatternMatcher æ¥å£
- `pkg/memory/logic/manager.go` - LogicMemoryManager
- `pkg/memory/logic/event.go` - Event é€šç”¨ç»“æ„

**æ ¸å¿ƒé€»è¾‘**ï¼š

```go
// manager.go - æ ¸å¿ƒç®¡ç†å™¨
func (m *LogicMemoryManager) ProcessEvent(ctx context.Context, event Event) error {
    // 1. éå†æ‰€æœ‰ Matcher
    var allMemories []*LogicMemory
    for _, matcher := range m.matchers {
        if contains(matcher.SupportedEventTypes(), event.Type) {
            memories, err := matcher.MatchEvent(ctx, event)
            if err != nil {
                log.Warnf("Matcher failed: %v", err)
                continue
            }
            allMemories = append(allMemories, memories...)
        }
    }

    // 2. ä¿å­˜æˆ–æ›´æ–° Memory
    for _, mem := range allMemories {
        existing, err := m.store.Get(ctx, mem.Namespace, mem.Key)
        if err == nil && existing != nil {
            // æ›´æ–°å·²æœ‰ Memoryï¼ˆæå‡ç½®ä¿¡åº¦ã€ç´¯ç§¯è¯æ®ï¼‰
            m.mergeMemory(existing, mem)
            m.store.Save(ctx, existing)
        } else {
            // åˆ›å»ºæ–° Memory
            m.store.Save(ctx, mem)
        }
    }

    return nil
}

// mergeMemory åˆå¹¶æ–°æ—§ Memoryï¼ˆæå‡ç½®ä¿¡åº¦ï¼‰
func (m *LogicMemoryManager) mergeMemory(existing, new *LogicMemory) {
    // å¢åŠ è®¿é—®è®¡æ•°
    existing.AccessCount++

    // æå‡ç½®ä¿¡åº¦ï¼ˆæœ€å¤šæå‡ 10%ï¼‰
    boost := 0.05
    existing.Provenance.Confidence = min(existing.Provenance.Confidence + boost, 1.0)

    // åˆå¹¶ Valueï¼ˆåº”ç”¨å±‚è‡ªå®šä¹‰é€»è¾‘ï¼‰
    // ...

    existing.UpdatedAt = time.Now()
}
```

**éªŒæ”¶æ ‡å‡†**ï¼š
- [ ] PatternMatcher æ¥å£è®¾è®¡åˆç†
- [ ] LogicMemoryManager æ ¸å¿ƒé€»è¾‘å®Œæ•´
- [ ] æ”¯æŒå¤š Matcher å¹¶è¡Œè¯†åˆ«
- [ ] Memory åˆå¹¶é€»è¾‘æµ‹è¯•é€šè¿‡

---

#### Day 5: Middleware é›†æˆ

**æ–°å»ºæ–‡ä»¶**ï¼š
- `pkg/middleware/logic_memory.go` - LogicMemoryMiddleware
- `pkg/middleware/logic_memory_test.go` - å•å…ƒæµ‹è¯•

**é›†æˆç‚¹**ï¼š

```go
// 1. è®¢é˜… EventBus
func (m *LogicMemoryMiddleware) OnAgentStart(ctx context.Context, agentID string) error {
    // è®¢é˜…æ‰€æœ‰é€šé“ï¼ˆæ ¹æ®é…ç½®ï¼‰
    if contains(m.config.CaptureChannels, types.ChannelControl) {
        m.eventBus.OnControl("*", m.handleControlEvent)
    }
    if contains(m.config.CaptureChannels, types.ChannelMonitor) {
        m.eventBus.OnMonitor("*", m.handleMonitorEvent)
    }
    return nil
}

// 2. æ³¨å…¥ Memory åˆ° Prompt
func (m *LogicMemoryMiddleware) injectMemories(msgs []types.Message, memories []*logic.LogicMemory) []types.Message {
    if len(memories) == 0 {
        return msgs
    }

    // æ„å»º Memory æ³¨å…¥æ–‡æœ¬
    var builder strings.Builder
    builder.WriteString("\n\n## User Preferences and Memory\n\n")
    builder.WriteString("Based on past interactions, I've learned:\n\n")

    for i, mem := range memories {
        builder.WriteString(fmt.Sprintf(
            "%d. **%s** (%s): %s (Confidence: %.0f%%)\n",
            i+1, mem.Type, mem.Key, mem.Description, mem.Provenance.Confidence*100,
        ))
    }

    builder.WriteString("\nPlease apply these preferences naturally in your response.\n")

    // æ³¨å…¥åˆ°ç¬¬ä¸€ä¸ª system message
    for i, msg := range msgs {
        if msg.Role == "system" {
            msgs[i].Content += builder.String()
            break
        }
    }

    return msgs
}
```

**éªŒæ”¶æ ‡å‡†**ï¼š
- [ ] Middleware å¯æ³¨å†Œåˆ° Agent
- [ ] EventBus è®¢é˜…æˆåŠŸ
- [ ] Memory æ­£ç¡®æ³¨å…¥åˆ° Prompt
- [ ] æ€§èƒ½æµ‹è¯•ï¼šå¼€é”€ < 5%

---

### Week 2: é«˜çº§åŠŸèƒ½ï¼ˆAster SDK å±‚ï¼‰

#### Day 6-7: Consolidation å’Œ Pruning

**æ–°å»ºæ–‡ä»¶**ï¼š
- `pkg/memory/logic/consolidation.go` - Memory åˆå¹¶
- `pkg/memory/logic/pruning.go` - Memory æ¸…ç†

**Consolidationï¼ˆå¤ç”¨ç°æœ‰ ConsolidationEngineï¼‰**ï¼š

```go
// consolidation.go

// ConsolidateMemories åˆå¹¶å†—ä½™ Memory
func (m *LogicMemoryManager) ConsolidateMemories(ctx context.Context, namespace string) error {
    // 1. è·å–æ‰€æœ‰ Memory
    memories, _ := m.store.List(ctx, namespace)

    // 2. æŒ‰ç±»å‹åˆ†ç»„
    grouped := m.groupByType(memories)

    // 3. å¯¹æ¯ç»„æ‰§è¡Œåˆå¹¶
    for memType, group := range grouped {
        if len(group) < 2 {
            continue
        }

        // ä½¿ç”¨ç°æœ‰ ConsolidationEngineï¼ˆåŸºäºç›¸ä¼¼åº¦ï¼‰
        merged := m.consolidation.Consolidate(ctx, group)
        for _, mem := range merged {
            m.store.Save(ctx, mem)
        }

        // åˆ é™¤è¢«åˆå¹¶çš„ Memory
        for _, oldMem := range group {
            if !contains(merged, oldMem) {
                m.store.Delete(ctx, namespace, oldMem.Key)
            }
        }
    }

    return nil
}
```

**Pruningï¼ˆæ¸…ç†ä½ä»·å€¼ Memoryï¼‰**ï¼š

```go
// pruning.go

// PruneCriteria æ¸…ç†æ¡ä»¶
type PruneCriteria struct {
    MinConfidence    float64       // æœ€ä½ç½®ä¿¡åº¦
    MaxAge           time.Duration // æœ€å¤§å¹´é¾„
    MinAccessCount   int           // æœ€å°‘è®¿é—®æ¬¡æ•°
    SinceLastAccess  time.Duration // æœ€åè®¿é—®æ—¶é—´
}

// PruneMemories æ¸…ç†ä½ä»·å€¼ Memory
func (m *LogicMemoryManager) PruneMemories(ctx context.Context, criteria PruneCriteria) (int, error) {
    // 1. æŸ¥è¯¢ç¬¦åˆæ¡ä»¶çš„ Memory
    allMemories, _ := m.store.List(ctx, "")

    // 2. è¿‡æ»¤ä½ä»·å€¼ Memory
    var toDelete []string
    for _, mem := range allMemories {
        if m.shouldPrune(mem, criteria) {
            toDelete = append(toDelete, mem.Key)
        }
    }

    // 3. æ‰¹é‡åˆ é™¤
    for _, key := range toDelete {
        m.store.Delete(ctx, mem.Namespace, key)
    }

    return len(toDelete), nil
}

// shouldPrune åˆ¤æ–­æ˜¯å¦åº”è¯¥æ¸…ç†
func (m *LogicMemoryManager) shouldPrune(mem *LogicMemory, criteria PruneCriteria) bool {
    // ç½®ä¿¡åº¦è¿‡ä½
    if mem.Provenance.Confidence < criteria.MinConfidence {
        return true
    }

    // å¤ªä¹…æœªè®¿é—®
    if time.Since(mem.LastAccessed) > criteria.SinceLastAccess {
        return true
    }

    // è®¿é—®æ¬¡æ•°è¿‡å°‘ä¸”å¹´é¾„è¿‡å¤§
    if mem.AccessCount < criteria.MinAccessCount && time.Since(mem.CreatedAt) > criteria.MaxAge {
        return true
    }

    return false
}
```

**éªŒæ”¶æ ‡å‡†**ï¼š
- [ ] Consolidation åˆå¹¶ç›¸ä¼¼ Memory
- [ ] Pruning æ¸…ç†ä½ä»·å€¼ Memory
- [ ] å®šæ—¶ä»»åŠ¡å¯é…ç½®ï¼ˆcronï¼‰
- [ ] æ—¥å¿—è®°å½•åˆå¹¶å’Œæ¸…ç†ç»Ÿè®¡

---

#### Day 8-9: ç›‘æ§å’Œå·¥å…·

**æ–°å»ºæ–‡ä»¶**ï¼š
- `pkg/memory/logic/metrics.go` - Prometheus æŒ‡æ ‡
- `pkg/tools/logic_memory_tool.go` - Logic Memory å·¥å…·

**Prometheus ç›‘æ§**ï¼š

```go
// metrics.go
var (
    memoryTotal = promauto.NewGaugeVec(
        prometheus.GaugeOpts{
            Name: "logic_memory_total",
            Help: "Total number of logic memories",
        },
        []string{"namespace", "type", "scope"},
    )

    memoryProcessDuration = promauto.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "logic_memory_process_duration_seconds",
            Help:    "Time to process event and create memory",
            Buckets: prometheus.DefBuckets,
        },
        []string{"event_type"},
    )

    memoryRetrieveDuration = promauto.NewHistogram(
        prometheus.HistogramOpts{
            Name:    "logic_memory_retrieve_duration_seconds",
            Help:    "Time to retrieve memories",
            Buckets: prometheus.DefBuckets,
        },
    )
)
```

**Logic Memory å·¥å…·ï¼ˆä¾› Agent ä½¿ç”¨ï¼‰**ï¼š

```go
// pkg/tools/logic_memory_tool.go

// LogicMemoryTool å…è®¸ Agent ä¸»åŠ¨æŸ¥è¯¢å’Œæ›´æ–° Memory
type LogicMemoryTool struct {
    manager *logic.LogicMemoryManager
}

func (t *LogicMemoryTool) Definition() types.ToolDefinition {
    return types.ToolDefinition{
        Name: "logic_memory",
        Description: "Query and update logic memories (user preferences, behavior patterns)",
        InputSchema: jsonschema.Object{
            Properties: map[string]jsonschema.Schema{
                "action": {Type: "string", Enum: []string{"list", "get", "update"}},
                "type": {Type: "string"},
                "key": {Type: "string"},
                "value": {Type: "object"},
            },
            Required: []string{"action"},
        },
    }
}

func (t *LogicMemoryTool) Execute(ctx context.Context, input map[string]any) (string, error) {
    action := input["action"].(string)
    namespace := getNamespaceFromContext(ctx)

    switch action {
    case "list":
        memories, _ := t.manager.RetrieveMemories(ctx, namespace)
        return formatMemoriesAsMarkdown(memories), nil
    case "get":
        key := input["key"].(string)
        mem, _ := t.manager.store.Get(ctx, namespace, key)
        return formatMemoryAsMarkdown(mem), nil
    case "update":
        // Agent ä¸»åŠ¨æ›´æ–° Memory
        // ...
    }

    return "", nil
}
```

**éªŒæ”¶æ ‡å‡†**ï¼š
- [ ] Prometheus æŒ‡æ ‡å®Œæ•´
- [ ] Grafana Dashboard æ¨¡æ¿
- [ ] logic_memory å·¥å…·å¯ç”¨
- [ ] å·¥å…·æµ‹è¯•é€šè¿‡

---

#### Day 10: æ–‡æ¡£å’Œç¤ºä¾‹

**æ–°å»ºæ–‡ä»¶**ï¼š
- `docs/memory/LOGIC_MEMORY.md` - å®Œæ•´æ–‡æ¡£
- `examples/logic_memory/` - ç¤ºä¾‹ä»£ç 

**æ–‡æ¡£ç»“æ„**ï¼š

```markdown
# Logic Memory Framework

## Overview
ä»‹ç» Logic Memory çš„è®¾è®¡ç›®æ ‡ã€æ¶æ„ã€æ ¸å¿ƒæ¦‚å¿µ

## Quick Start
5 åˆ†é’Ÿå¿«é€Ÿå¼€å§‹

## Core Concepts
- Memory Types and Scopes
- PatternMatcher
- Consolidation and Pruning

## API Reference
å®Œæ•´ API æ–‡æ¡£

## Integration Guide
å¦‚ä½•åœ¨åº”ç”¨ä¸­é›†æˆ Logic Memory

## Best Practices
æœ€ä½³å®è·µå’Œå¸¸è§æ¨¡å¼

## FAQ
å¸¸è§é—®é¢˜è§£ç­”
```

**ç¤ºä¾‹ä»£ç **ï¼š

```go
// examples/logic_memory/basic/main.go

func main() {
    // 1. åˆ›å»º Logic Memory Store
    store := logic.NewPostgreSQLStore(db)

    // 2. å®ç° PatternMatcherï¼ˆåº”ç”¨å±‚è‡ªå®šä¹‰ï¼‰
    matcher := &MyPatternMatcher{}

    // 3. åˆ›å»º LogicMemoryManager
    manager := logic.NewManager(&logic.ManagerConfig{
        Store:    store,
        Matchers: []logic.PatternMatcher{matcher},
    })

    // 4. é…ç½® Middleware
    middleware := middleware.NewLogicMemoryMiddleware(&middleware.LogicMemoryConfig{
        Manager:          manager,
        EnableCapture:    true,
        EnableInjection:  true,
        MaxMemories:      5,
        MinConfidence:    0.6,
    })

    // 5. æ³¨å†Œåˆ° Agent
    deps.MiddlewareStack.Add(middleware)

    // å®Œæˆï¼Logic Memory è‡ªåŠ¨å·¥ä½œ
}
```

**éªŒæ”¶æ ‡å‡†**ï¼š
- [ ] æ–‡æ¡£å®Œæ•´ä¸”å‡†ç¡®
- [ ] ç¤ºä¾‹ä»£ç å¯è¿è¡Œ
- [ ] API æ–‡æ¡£æ¸…æ™°
- [ ] æ¶æ„å›¾å’Œæµç¨‹å›¾å®Œæ•´

---

### Week 3: YunJin é›†æˆç¤ºä¾‹ï¼ˆåº”ç”¨å±‚ï¼‰

#### Day 11-13: YunJin PatternMatcher å®ç°

**æ–°å»ºæ–‡ä»¶**ï¼ˆåœ¨ YunJin é¡¹ç›®ä¸­ï¼‰ï¼š
- `internal/memory/pattern_matcher.go` - YunJin çš„ PatternMatcher
- `internal/memory/memory_types.go` - YunJin å®šä¹‰çš„ Memory ç±»å‹

**YunJin è‡ªå®šä¹‰ Memory ç±»å‹**ï¼š

```go
// internal/memory/memory_types.go

const (
    TypeWritingTone      = "writing_tone"      // å†™ä½œè¯­æ°”åå¥½
    TypeMaterialSource   = "material_source"   // ç´ ææ¥æºåå¥½
    TypeStructure        = "structure"         // ç»“æ„åå¥½
    TypeWordChoice       = "word_choice"       // ç”¨è¯åå¥½
    TypeTopicSuitability = "topic_suitability" // ä¸»é¢˜é€‚é…æ€§
)

// WritingTonePreference å†™ä½œè¯­æ°”åå¥½
type WritingTonePreference struct {
    PreferredTone string   // "formal", "casual", "humorous"
    AvoidedPhrases []string // é¿å…çš„è¯æ±‡
    Examples       []RevisionExample
}

// RevisionExample ä¿®æ”¹ç¤ºä¾‹
type RevisionExample struct {
    From string
    To   string
    Reason string
}
```

**YunJin PatternMatcher å®ç°**ï¼š

```go
// internal/memory/pattern_matcher.go

type YunJinPatternMatcher struct {
    // å¯é€‰ï¼šä½¿ç”¨ LLM è¾…åŠ©è¯†åˆ«
    provider provider.Provider
}

func (m *YunJinPatternMatcher) SupportedEventTypes() []string {
    return []string{
        "user_revision",     // ç”¨æˆ·ä¿®æ”¹å†…å®¹
        "user_feedback",     // ç”¨æˆ·è¯„ä»·
        "topic_selection",   // ä¸»é¢˜é€‰æ‹©
        "material_rejection",// ç´ ææ‹’ç»
    }
}

func (m *YunJinPatternMatcher) MatchEvent(ctx context.Context, event logic.Event) ([]*logic.LogicMemory, error) {
    switch event.Type {
    case "user_revision":
        return m.matchRevisionPattern(ctx, event)
    case "user_feedback":
        return m.matchFeedbackPattern(ctx, event)
    // ...
    }
    return nil, nil
}

// matchRevisionPattern è¯†åˆ«ç”¨æˆ·ä¿®æ”¹æ¨¡å¼
func (m *YunJinPatternMatcher) matchRevisionPattern(ctx context.Context, event logic.Event) ([]*logic.LogicMemory, error) {
    original := event.Data["original"].(string)
    revised := event.Data["revised"].(string)

    var memories []*logic.LogicMemory

    // è§„åˆ™ 1: åˆ é™¤ä¹¦é¢è¯­
    if m.containsFormalWords(original) && !m.containsFormalWords(revised) {
        mem := &logic.LogicMemory{
            Namespace:   event.Source,
            Scope:       logic.ScopeUser,
            Type:        TypeWritingTone,
            Key:         "casual_tone_preference",
            Value: WritingTonePreference{
                PreferredTone: "casual",
                AvoidedPhrases: m.extractRemovedFormalWords(original, revised),
                Examples: []RevisionExample{{From: original, To: revised}},
            },
            Description: "ç”¨æˆ·åå¥½å£è¯­åŒ–è¡¨è¾¾ï¼Œé¿å…ä½¿ç”¨ä¹¦é¢è¯­",
            Provenance: &memory.MemoryProvenance{
                SourceType: memory.SourceUserInput,
                Confidence: 0.70,
            },
        }
        memories = append(memories, mem)
    }

    // è§„åˆ™ 2: å¢åŠ  emoji
    // è§„åˆ™ 3: ç¼©çŸ­æ®µè½
    // ...

    return memories, nil
}

// å¯é€‰ï¼šä½¿ç”¨ LLM è¾…åŠ©è¯†åˆ«ï¼ˆæ›´å‡†ç¡®ä½†æ›´æ…¢ï¼‰
func (m *YunJinPatternMatcher) matchWithLLM(ctx context.Context, original, revised string) (*logic.LogicMemory, error) {
    prompt := fmt.Sprintf(`
åˆ†æç”¨æˆ·çš„ä¿®æ”¹è¡Œä¸ºï¼Œè¯†åˆ«å†™ä½œåå¥½ã€‚

åŸæ–‡ï¼š%s
ä¿®æ”¹åï¼š%s

è¯·ç”¨ JSON è¿”å›ï¼š
{
  "type": "...",
  "key": "...",
  "description": "...",
  "confidence": 0.80
}
`, original, revised)

    response, _ := m.provider.CallModel(ctx, []types.Message{{Role: "user", Content: prompt}}, nil)
    // è§£æ JSON å¹¶æ„å»º LogicMemory
    // ...
}
```

**éªŒæ”¶æ ‡å‡†**ï¼š
- [ ] YunJinPatternMatcher å®ç°å®Œæ•´
- [ ] 5 ç§ Memory ç±»å‹å®šä¹‰æ¸…æ™°
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–æ‰€æœ‰è§„åˆ™
- [ ] å¯é€‰çš„ LLM è¾…åŠ©è¯†åˆ«

---

#### Day 14-15: YunJin é›†æˆå’Œæµ‹è¯•

**ä¿®æ”¹æ–‡ä»¶**ï¼ˆåœ¨ YunJin é¡¹ç›®ä¸­ï¼‰ï¼š
- `internal/agent/agent_manager.go` - é›†æˆ Logic Memory
- `cmd/server/main.go` - åˆå§‹åŒ–é…ç½®

**é›†æˆä»£ç **ï¼š

```go
// internal/agent/agent_manager.go

func NewAgentManager(config *Config) *AgentManager {
    // 1. åˆ›å»º Logic Memory Store
    logicStore := logic.NewPostgreSQLStore(config.DB)

    // 2. åˆ›å»º YunJin PatternMatcher
    matcher := memory.NewYunJinPatternMatcher(config.Provider)

    // 3. åˆ›å»º LogicMemoryManager
    logicManager := logic.NewManager(&logic.ManagerConfig{
        Store:    logicStore,
        Matchers: []logic.PatternMatcher{matcher},
    })

    // 4. åˆ›å»º LogicMemoryMiddleware
    logicMiddleware := middleware.NewLogicMemoryMiddleware(&middleware.LogicMemoryConfig{
        Manager:         logicManager,
        EventBus:        config.EventBus,
        EnableCapture:   true,
        CaptureChannels: []types.AgentChannel{types.ChannelControl, types.ChannelMonitor},
        EnableInjection: true,
        MaxMemories:     5,
        MinConfidence:   0.6,
        AsyncCapture:    true,
        CacheTTL:        time.Hour,
    })

    // 5. æ³¨å†Œåˆ° Middleware Stack
    config.MiddlewareStack.Add(logicMiddleware)

    return &AgentManager{
        // ...
        logicManager: logicManager,
    }
}

// æ‰‹åŠ¨è§¦å‘äº‹ä»¶ï¼ˆå¯é€‰ï¼‰
func (m *AgentManager) HandleUserRevision(ctx context.Context, sessionID uint, original, revised string) {
    event := logic.Event{
        Type:   "user_revision",
        Source: fmt.Sprintf("user:%d", m.getUserID(sessionID)),
        Data: map[string]any{
            "session_id": sessionID,
            "original":   original,
            "revised":    revised,
        },
        Timestamp: time.Now(),
    }

    m.logicManager.ProcessEvent(ctx, event)
}
```

**ç«¯åˆ°ç«¯æµ‹è¯•**ï¼š

```go
// test/logic_memory_test.go

func TestLogicMemoryE2E(t *testing.T) {
    // 1. ç”¨æˆ·ç¬¬ä¸€æ¬¡åˆ›ä½œï¼ˆç”Ÿæˆæ­£å¼è¡¨è¾¾ï¼‰
    session := createSession(userID, "æŠ€æœ¯æ–‡ç« ")
    content := generateContent(session, "ä»‹ç» Go è¯­è¨€ç‰¹æ€§")
    assert.Contains(t, content, "ç„¶è€Œ") // æ­£å¼è¯­æ°”

    // 2. ç”¨æˆ·ä¿®æ”¹ä¸ºå£è¯­åŒ–
    revisedContent := strings.ReplaceAll(content, "ç„¶è€Œ", "ä¸è¿‡")
    handleUserRevision(session.ID, content, revisedContent)

    // 3. ç­‰å¾… Memory å¤„ç†
    time.Sleep(100 * time.Millisecond)

    // 4. éªŒè¯ Memory åˆ›å»º
    memories := getLogicMemories(userID)
    assert.Equal(t, 1, len(memories))
    assert.Equal(t, "casual_tone_preference", memories[0].Key)
    assert.Contains(t, memories[0].Description, "å£è¯­åŒ–")

    // 5. ç”¨æˆ·ç¬¬äºŒæ¬¡åˆ›ä½œï¼ˆåº”è¯¥åº”ç”¨ Memoryï¼‰
    session2 := createSession(userID, "æŠ€æœ¯æ–‡ç« ")
    content2 := generateContent(session2, "ä»‹ç» Rust è¯­è¨€ç‰¹æ€§")
    assert.NotContains(t, content2, "ç„¶è€Œ") // å·²å­¦ä¹ ï¼Œä¸å†ä½¿ç”¨æ­£å¼è¯­æ°”
    assert.Contains(t, content2, "ä¸è¿‡")    // ä½¿ç”¨å£è¯­åŒ–è¡¨è¾¾

    // 6. éªŒè¯ Memory ç½®ä¿¡åº¦æå‡
    updatedMemories := getLogicMemories(userID)
    assert.GreaterOrEqual(t, updatedMemories[0].Provenance.Confidence, 0.75)
}
```

**éªŒæ”¶æ ‡å‡†**ï¼š
- [ ] YunJin å®Œæ•´é›†æˆ Logic Memory
- [ ] ç«¯åˆ°ç«¯æµ‹è¯•é€šè¿‡
- [ ] æ€§èƒ½æµ‹è¯•ï¼šå¯¹ä¸»æµç¨‹å½±å“ < 3%
- [ ] ç”¨æˆ·ä½“éªŒæµ‹è¯•ï¼šMemory æ³¨å…¥å‡†ç¡®

---

### Week 4: æ–‡æ¡£å’Œå‘å¸ƒ

#### Day 16-18: å®Œå–„æ–‡æ¡£å’Œç¤ºä¾‹

**Aster SDK æ–‡æ¡£**ï¼š
- `docs/memory/LOGIC_MEMORY.md` - å®Œæ•´æ–‡æ¡£
- `docs/memory/ARCHITECTURE.md` - æ¶æ„è®¾è®¡
- `docs/memory/API.md` - API å‚è€ƒ
- `docs/memory/INTEGRATION_GUIDE.md` - é›†æˆæŒ‡å—
- `examples/logic_memory/` - å¤šä¸ªç¤ºä¾‹

**YunJin æ–‡æ¡£**ï¼š
- `docs/LOGIC_MEMORY_INTEGRATION.md` - é›†æˆè¯´æ˜
- `docs/PATTERN_MATCHER.md` - PatternMatcher å¼€å‘æŒ‡å—

**éªŒæ”¶æ ‡å‡†**ï¼š
- [ ] æ–‡æ¡£å®Œæ•´ä¸”å‡†ç¡®
- [ ] ç¤ºä¾‹ä»£ç å¯è¿è¡Œ
- [ ] æ¶æ„å›¾æ¸…æ™°
- [ ] API æ–‡æ¡£å®Œæ•´

---

#### Day 19-20: æ€§èƒ½ä¼˜åŒ–å’Œå‘å¸ƒå‡†å¤‡

**æ€§èƒ½ä¼˜åŒ–**ï¼š
- [ ] Memory æŸ¥è¯¢ç¼“å­˜ï¼ˆRedisï¼‰
- [ ] æ‰¹é‡äº‹ä»¶å¤„ç†ï¼ˆå‡å°‘ goroutineï¼‰
- [ ] æ•°æ®åº“ç´¢å¼•ä¼˜åŒ–
- [ ] Prometheus ç›‘æ§å®Œå–„

**å‘å¸ƒå‡†å¤‡**ï¼š
- [ ] ç‰ˆæœ¬å·ï¼šv0.1.0-beta
- [ ] CHANGELOG.md
- [ ] è¿ç§»æŒ‡å—ï¼ˆå¯¹ç°æœ‰ Aster ç”¨æˆ·ï¼‰
- [ ] å®‰å…¨å®¡è®¡ï¼ˆPII æ£€æŸ¥ï¼‰

---

## å››ã€æ ¸å¿ƒè®¾è®¡å†³ç­–å’Œæƒè¡¡

### 4.1 ä¸ºä»€ä¹ˆä¸åœ¨ Session å±‚å®ç°ï¼Ÿ

**å†³ç­–**ï¼šåœ¨ Memory å±‚å®ç°ï¼Œè€Œé Session å±‚

**ç†ç”±**ï¼š
- Session æ˜¯ä¸´æ—¶æ€§çš„ï¼ŒLogic Memory éœ€è¦è·¨ Session æŒä¹…åŒ–
- Memory å±‚å·²æœ‰å®Œå–„çš„ Provenanceã€Consolidation æœºåˆ¶ï¼Œå¯å¤ç”¨
- ç¬¦åˆ Aster çš„å››å±‚ Memory æ¶æ„ï¼ˆText/Working/Semantic/Logicï¼‰

### 4.2 ä¸ºä»€ä¹ˆæ”¯æŒå¤š PatternMatcherï¼Ÿ

**å†³ç­–**ï¼šæ”¯æŒå¤šä¸ª PatternMatcher å¹¶è¡Œå·¥ä½œ

**ç†ç”±**ï¼š
- åº”ç”¨å±‚å¯èƒ½éœ€è¦å¤šç§è¯†åˆ«ç­–ç•¥ï¼ˆè§„åˆ™ + LLM + ç»Ÿè®¡ï¼‰
- ä¸åŒ Memory ç±»å‹å¯èƒ½éœ€è¦ä¸åŒçš„ Matcher
- æé«˜æ¡†æ¶çš„çµæ´»æ€§å’Œå¯æ‰©å±•æ€§

### 4.3 ä¸ºä»€ä¹ˆå¼‚æ­¥æ•è·ï¼Ÿ

**å†³ç­–**ï¼šé»˜è®¤å¼‚æ­¥æ•è·ï¼Œå¯é…ç½®åŒæ­¥æ¨¡å¼

**ç†ç”±**ï¼š
- ä¸é˜»å¡ä¸»æµç¨‹ï¼ˆç”¨æˆ·ä½“éªŒä¼˜å…ˆï¼‰
- äº‹ä»¶å¤„ç†å¯èƒ½è€—æ—¶ï¼ˆLLM è°ƒç”¨ã€æ•°æ®åº“å†™å…¥ï¼‰
- å¤§å¤šæ•°åœºæ™¯ä¸‹ï¼ŒMemory ä¸éœ€è¦å®æ—¶ç”Ÿæ•ˆ

**æƒè¡¡**ï¼š
- å¼‚æ­¥å¯èƒ½ä¸¢å¤±éƒ¨åˆ†äº‹ä»¶ï¼ˆé€šè¿‡ buffered channel ç¼“è§£ï¼‰
- è°ƒè¯•éš¾åº¦å¢åŠ ï¼ˆé€šè¿‡æ—¥å¿—å’Œç›‘æ§ç¼“è§£ï¼‰

### 4.4 ä¸ºä»€ä¹ˆä¸è‡ªåŠ¨å¯ç”¨ï¼Ÿ

**å†³ç­–**ï¼šLogic Memory éœ€è¦åº”ç”¨å±‚æ˜¾å¼é…ç½®å’Œå¯ç”¨

**ç†ç”±**ï¼š
- éœ€è¦åº”ç”¨å±‚æä¾› PatternMatcherï¼ˆæ— æ³•é€šç”¨ï¼‰
- éœ€è¦åº”ç”¨å±‚å®šä¹‰ Memory ç±»å‹ï¼ˆä¸šåŠ¡ç›¸å…³ï¼‰
- é¿å…å¯¹ä¸éœ€è¦ Logic Memory çš„åº”ç”¨é€ æˆæ€§èƒ½å¼€é”€

---

## äº”ã€ä¸æ¼”è®²å†…å®¹çš„å¯¹åº”

### 5.1 Memory OS ç³»ç»ŸåŒ–ç®¡ç† âœ…

**æ¼”è®²è¦æ±‚**ï¼š
> "Memory OS æ˜¯ä¸€ä¸ªä¸¥è°¨çš„ç³»ç»Ÿï¼Œä½ è¦ä»€ä¹ˆæ—¶å€™å†™å…¥ï¼Œå…·ä½“ä¸Šæ¥äº†ä¸€ä¸ª memoryï¼Œé‚£è¿™ä¸ª memory ä½ æ˜¯è¦å†™å…¥çŸ­æœŸã€å†™å…¥ä¸­æœŸã€å†™å…¥é•¿æœŸã€‚ä¸€æ—¦å®ƒå†™å…¥äº†çŸ­æœŸä¹‹åï¼Œå®ƒå¤šä¹…å˜æˆé•¿æœŸï¼Œå¤šä¹…ä¼šå˜æˆä¸­æœŸã€‚"

**Aster å®ç°**ï¼š
- **ä¸‰ç§ä½œç”¨åŸŸ**ï¼šSessionï¼ˆçŸ­æœŸï¼‰ã€Userï¼ˆä¸­æœŸï¼‰ã€Globalï¼ˆé•¿æœŸï¼‰
- **è‡ªåŠ¨è½¬æ¢**ï¼šåŸºäºç½®ä¿¡åº¦ã€è®¿é—®é¢‘ç‡è‡ªåŠ¨å‡çº§ä½œç”¨åŸŸ
- **Consolidation**ï¼šå®šæœŸåˆå¹¶ç›¸ä¼¼ Memoryï¼Œæ¸…ç†å†—ä½™
- **Pruning**ï¼šè‡ªåŠ¨æ¸…ç†ä½ä»·å€¼ Memory

### 5.2 Memory RLï¼ˆæš‚ä¸å®ç°ï¼‰âŒ

**æ¼”è®²è¦æ±‚**ï¼š
> "ä¸“é—¨ç”¨ RL æ¨¡å‹å»åšçŸ­æœŸè®°å¿†çš„è¿™ç§ updateï¼Œç„¶åä»–ä»¬çš„ä¸€äº›å¥–åŠ±å°±å¯ä»¥æ˜¯ï¼Œä½ å­˜è¿›å»çš„è®°å¿†æ˜¯ä¸æ˜¯è¶³å¤Ÿçš„ç²¾ç‚¼ï¼Ÿ"

**Aster æ–¹æ¡ˆ**ï¼š
- **Phase 1ï¼ˆå½“å‰ï¼‰**ï¼šåŸºäºè§„åˆ™ + ç½®ä¿¡åº¦çš„å¯å‘å¼æ–¹æ³•
- **Phase 2ï¼ˆæœªæ¥ï¼‰**ï¼šLLM é©±åŠ¨çš„ Pattern è¯†åˆ«
- **Phase 3ï¼ˆç ”ç©¶ï¼‰**ï¼šRL-based Memory ç®¡ç†

**ç†ç”±**ï¼šRL éœ€è¦å¤§é‡æ•°æ®å’Œè®­ç»ƒï¼Œå½“å‰å¯å‘å¼æ–¹æ³•å·²è¶³å¤Ÿå®ç”¨ã€‚

### 5.3 Logic Memoryï¼ˆæ‰§è¡Œè½¨è¿¹ï¼‰âœ…

**æ¼”è®²è¦æ±‚**ï¼š
> "æˆ‘è¿‡å¾€æ‰§è¡Œäº†ä»€ä¹ˆæ“ä½œï¼Œç„¶åä»–æˆåŠŸäº†ï¼›æ‰§è¡Œäº†ä»€ä¹ˆæ“ä½œï¼Œä»–å¤±è´¥äº†ï¼Œç„¶åå¤±è´¥äº†ä¹‹åæˆ‘å»åš reflectionï¼Œç„¶åä»–åˆæˆåŠŸäº†ï¼Œé‚£æˆ‘è¿™æ—¶å€™è¿™ä¸ª reflection çš„ä¸œè¥¿ä½œä¸ºæˆ‘çš„ä¸€ä¸ª memoryã€‚"

**Aster å®ç°**ï¼š
- **Event é©±åŠ¨**ï¼šè‡ªåŠ¨æ•è·æ‰€æœ‰äº‹ä»¶ï¼ˆæˆåŠŸ/å¤±è´¥ï¼‰
- **PatternMatcher**ï¼šè¯†åˆ«æˆåŠŸ/å¤±è´¥æ¨¡å¼
- **Provenance**ï¼šè¿½è¸ª Memory æ¥æºå’Œç½®ä¿¡åº¦
- **Consolidation**ï¼šåˆå¹¶ç›¸å…³ Memory å½¢æˆç»éªŒ

**æœªæ¥å¢å¼º**ï¼š
- Reflection Engineï¼šä¸“é—¨çš„åæ€æ¨¡å—
- Success Pattern Miningï¼šä»æˆåŠŸæ¡ˆä¾‹ä¸­æå–æ¨¡å¼
- Failure Pattern Detectionï¼šè¯†åˆ«å¤±è´¥æ¨¡å¼å¹¶é¿å…

### 5.4 Critical Learning âœ…

**æ¼”è®²è¦æ±‚**ï¼š
> "æˆ‘åœ¨ code agent çš„æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œæˆ‘æœ‰ä¸€äº›ä»£ç è§„èŒƒæˆ‘è®©å®ƒå»éµå®ˆï¼Œç„¶åæˆ‘åœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­æˆ‘å‘ç°æˆ‘éœ€è¦è¡¥å……ä¸€äº›ä»£ç è§„èŒƒï¼Œè¿™ç§å»è¡¥å……çš„è¿™éƒ¨åˆ†å…¶å®å°±æ˜¯ä¸€ä¸ª critical learning çš„è¿‡ç¨‹ã€‚"

**Aster å®ç°**ï¼š
- **ç”¨æˆ·ä¿®æ”¹æ•è·**ï¼šè‡ªåŠ¨æ•è·ç”¨æˆ·å¯¹ç”Ÿæˆå†…å®¹çš„ä¿®æ”¹
- **Pattern è¯†åˆ«**ï¼šä»ä¿®æ”¹ä¸­æå–è§„èŒƒï¼ˆå¦‚"é¿å…ä¹¦é¢è¯­"ï¼‰
- **Memory ç´¯ç§¯**ï¼šå¤šæ¬¡ä¿®æ”¹æå‡ç½®ä¿¡åº¦ï¼Œå½¢æˆå¯é çš„è§„èŒƒ
- **è‡ªåŠ¨åº”ç”¨**ï¼šåç»­ç”Ÿæˆè‡ªåŠ¨éµå®ˆå­¦åˆ°çš„è§„èŒƒ

---

## å…­ã€å…³é”®æ–‡ä»¶æ¸…å•

### Aster SDK æ–°å¢æ–‡ä»¶ï¼ˆæ¡†æ¶å±‚ï¼‰

| æ–‡ä»¶è·¯å¾„ | åŠŸèƒ½ | è¡Œæ•°ä¼°è®¡ |
|---------|------|---------|
| `pkg/memory/logic/types.go` | æ ¸å¿ƒæ•°æ®ç»“æ„ | 200 |
| `pkg/memory/logic/store.go` | å­˜å‚¨æ¥å£ | 150 |
| `pkg/memory/logic/store_postgres.go` | PostgreSQL å®ç° | 300 |
| `pkg/memory/logic/store_inmemory.go` | å†…å­˜å®ç° | 150 |
| `pkg/memory/logic/matcher.go` | PatternMatcher æ¥å£ | 100 |
| `pkg/memory/logic/manager.go` | LogicMemoryManager | 400 |
| `pkg/memory/logic/event.go` | Event ç»“æ„ | 100 |
| `pkg/memory/logic/consolidation.go` | Memory åˆå¹¶ | 250 |
| `pkg/memory/logic/pruning.go` | Memory æ¸…ç† | 200 |
| `pkg/memory/logic/metrics.go` | Prometheus æŒ‡æ ‡ | 100 |
| `pkg/middleware/logic_memory.go` | Middleware | 350 |
| `pkg/tools/logic_memory_tool.go` | Logic Memory å·¥å…· | 200 |
| **æµ‹è¯•æ–‡ä»¶** | | |
| `pkg/memory/logic/*_test.go` | å•å…ƒæµ‹è¯• | 800 |
| `test/integration/logic_memory_test.go` | é›†æˆæµ‹è¯• | 300 |
| **æ–‡æ¡£** | | |
| `docs/memory/LOGIC_MEMORY.md` | å®Œæ•´æ–‡æ¡£ | - |
| `docs/memory/ARCHITECTURE.md` | æ¶æ„è®¾è®¡ | - |
| `docs/memory/API.md` | API å‚è€ƒ | - |
| `examples/logic_memory/` | ç¤ºä¾‹ä»£ç  | 500 |

**æ€»è®¡**ï¼šçº¦ 3,600 è¡Œä»£ç  + æ–‡æ¡£

### YunJin åº”ç”¨å±‚æ–‡ä»¶ï¼ˆç¤ºä¾‹ï¼‰

| æ–‡ä»¶è·¯å¾„ | åŠŸèƒ½ | è¡Œæ•°ä¼°è®¡ |
|---------|------|---------|
| `internal/memory/pattern_matcher.go` | YunJin PatternMatcher | 400 |
| `internal/memory/memory_types.go` | è‡ªå®šä¹‰ Memory ç±»å‹ | 150 |
| `internal/agent/agent_manager.go` | é›†æˆ Logic Memory | +100 |
| `cmd/server/main.go` | åˆå§‹åŒ–é…ç½® | +50 |
| `test/logic_memory_test.go` | ç«¯åˆ°ç«¯æµ‹è¯• | 300 |

**æ€»è®¡**ï¼šçº¦ 1,000 è¡Œä»£ç 

---

## ä¸ƒã€æ—¶é—´çº¿å’Œé‡Œç¨‹ç¢‘

| å‘¨ | æ—¥æœŸ | é‡Œç¨‹ç¢‘ | äº¤ä»˜ç‰© | éªŒæ”¶æ ‡å‡† |
|----|------|--------|--------|---------|
| **Week 1** | | **æ ¸å¿ƒæ¡†æ¶** | | |
| | Day 1-2 | æ•°æ®æ¨¡å‹å’Œå­˜å‚¨ | types.go, store*.go | å•å…ƒæµ‹è¯•é€šè¿‡ |
| | Day 3-4 | PatternMatcher å’Œ Manager | matcher.go, manager.go | æ ¸å¿ƒé€»è¾‘å®Œæ•´ |
| | Day 5 | Middleware é›†æˆ | logic_memory.go (middleware) | Memory æ³¨å…¥æˆåŠŸ |
| **Week 2** | | **é«˜çº§åŠŸèƒ½** | | |
| | Day 6-7 | Consolidation å’Œ Pruning | consolidation.go, pruning.go | åˆå¹¶å’Œæ¸…ç†æµ‹è¯•é€šè¿‡ |
| | Day 8-9 | ç›‘æ§å’Œå·¥å…· | metrics.go, logic_memory_tool.go | Prometheus æŒ‡æ ‡å®Œæ•´ |
| | Day 10 | æ–‡æ¡£å’Œç¤ºä¾‹ | docs/, examples/ | æ–‡æ¡£å®Œæ•´ |
| **Week 3** | | **YunJin é›†æˆ** | | |
| | Day 11-13 | PatternMatcher å®ç° | pattern_matcher.go (YunJin) | 5 ç§è§„åˆ™å®ç° |
| | Day 14-15 | é›†æˆå’Œæµ‹è¯• | ä¿®æ”¹ agent_manager.go | E2E æµ‹è¯•é€šè¿‡ |
| **Week 4** | | **å‘å¸ƒå‡†å¤‡** | | |
| | Day 16-18 | å®Œå–„æ–‡æ¡£ | å®Œæ•´æ–‡æ¡£å’Œç¤ºä¾‹ | æ–‡æ¡£å®Œæ•´ |
| | Day 19-20 | æ€§èƒ½ä¼˜åŒ–å’Œå‘å¸ƒ | v0.1.0-beta | æ€§èƒ½è¾¾æ ‡ |

**æ€»è®¡**ï¼š20 ä¸ªå·¥ä½œæ—¥ï¼ˆ3-4 å‘¨ï¼‰

---

## å…«ã€æˆåŠŸæŒ‡æ ‡

### Aster SDK å±‚é¢

| æŒ‡æ ‡ | ç›®æ ‡ | éªŒè¯æ–¹å¼ |
|-----|------|---------|
| **é€šç”¨æ€§** | æ”¯æŒ 3+ åº”ç”¨åœºæ™¯ | YunJin + 2 ä¸ªå…¶ä»–ç¤ºä¾‹ |
| **æ€§èƒ½** | ä¸»æµç¨‹å¼€é”€ < 5% | æ€§èƒ½åŸºå‡†æµ‹è¯• |
| **å¯æ‰©å±•æ€§** | æ”¯æŒè‡ªå®šä¹‰ PatternMatcher | æ¥å£è®¾è®¡å’Œæ–‡æ¡£ |
| **æ˜“ç”¨æ€§** | 10 è¡Œä»£ç å®Œæˆé›†æˆ | Quick Start ç¤ºä¾‹ |
| **æµ‹è¯•è¦†ç›–ç‡** | > 80% | go test -cover |

### YunJin åº”ç”¨å±‚é¢

| æŒ‡æ ‡ | ç›®æ ‡ | éªŒè¯æ–¹å¼ |
|-----|------|---------|
| **Memory æ•è·ç‡** | > 80% | æ¯æ¬¡ç”¨æˆ·ä¿®æ”¹éƒ½è§¦å‘ |
| **Pattern å‡†ç¡®ç‡** | > 70% | äººå·¥è¯„ä¼° 50 ä¸ªæ ·æœ¬ |
| **ç”¨æˆ·æ»¡æ„åº¦** | > 4.0/5.0 | Beta ç”¨æˆ·é—®å· |
| **é¦–æ¬¡æˆåŠŸç‡æå‡** | 60% â†’ 85% | A/B æµ‹è¯• |

---

## ä¹ã€é£é™©å’Œç¼“è§£

### é£é™© 1ï¼šæ¡†æ¶è¿‡äºå¤æ‚ âš ï¸

**é£é™©**ï¼šåº”ç”¨å±‚é›†æˆæˆæœ¬é«˜

**ç¼“è§£**ï¼š
- æä¾› Quick Startï¼ˆ10 è¡Œä»£ç ï¼‰
- æä¾› 3+ å®Œæ•´ç¤ºä¾‹
- æä¾›é»˜è®¤ PatternMatcherï¼ˆåŸºäºè§„åˆ™ï¼‰

### é£é™© 2ï¼šæ€§èƒ½å½±å“ä¸»æµç¨‹ âš ï¸

**é£é™©**ï¼šMemory æ•è·å’ŒæŸ¥è¯¢å½±å“æ€§èƒ½

**ç¼“è§£**ï¼š
- é»˜è®¤å¼‚æ­¥æ•è·
- Redis ç¼“å­˜ TopK Memory
- æ•°æ®åº“ç´¢å¼•ä¼˜åŒ–
- å¯é…ç½®å…³é—­ Logic Memory

### é£é™© 3ï¼šPatternMatcher å‡†ç¡®ç‡ä½ âš ï¸

**é£é™©**ï¼šåŸºäºè§„åˆ™çš„è¯†åˆ«ä¸å‡†ç¡®

**ç¼“è§£**ï¼š
- æ”¯æŒ LLM è¾…åŠ©è¯†åˆ«ï¼ˆå¯é€‰ï¼‰
- ç”¨æˆ·å¯ç¼–è¾‘/åˆ é™¤ Memory
- ç½®ä¿¡åº¦é˜ˆå€¼è¿‡æ»¤ï¼ˆMinConfidenceï¼‰
- æœªæ¥å¼•å…¥ RL ä¼˜åŒ–

### é£é™© 4ï¼šå­˜å‚¨æˆæœ¬ âš ï¸

**é£é™©**ï¼šå¤§é‡ Memory å¯¼è‡´å­˜å‚¨æˆæœ¬é«˜

**ç¼“è§£**ï¼š
- è‡ªåŠ¨ Pruningï¼ˆæ¸…ç†ä½ä»·å€¼ Memoryï¼‰
- æ¯ç”¨æˆ·é™åˆ¶ Memory æ•°é‡
- å®šæœŸ Consolidationï¼ˆåˆå¹¶ç›¸ä¼¼ Memoryï¼‰
- æ”¯æŒ Redis Storeï¼ˆä½æˆæœ¬ï¼‰

---

## åã€æœªæ¥æ¼”è¿›æ–¹å‘

### Phase 2: LLM é©±åŠ¨çš„ Pattern è¯†åˆ«ï¼ˆ2-3 ä¸ªæœˆï¼‰

**ç›®æ ‡**ï¼šæå‡ Pattern è¯†åˆ«å‡†ç¡®ç‡åˆ° 90%+

**æ–¹æ¡ˆ**ï¼š
- ä½¿ç”¨ LLM åˆ†æäº‹ä»¶ï¼Œç”Ÿæˆç»“æ„åŒ– Pattern
- è®­ç»ƒä¸“é—¨çš„ Pattern è¯†åˆ«æ¨¡å‹
- æ”¯æŒå¤šæ¨¡æ€äº‹ä»¶ï¼ˆæ–‡æœ¬ + å›¾åƒï¼‰

### Phase 3: Reflection Engineï¼ˆ3-4 ä¸ªæœˆï¼‰

**ç›®æ ‡**ï¼šå®ç°è‡ªæˆ‘åæ€å’Œé”™è¯¯å½’å› 

**æ–¹æ¡ˆ**ï¼š
- ä¸“é—¨çš„ ReflectionEngine æ¨¡å—
- ä»å¤±è´¥äº‹ä»¶ä¸­è‡ªåŠ¨ç”Ÿæˆ Reflection
- Reflection ä½œä¸ºé«˜ç½®ä¿¡åº¦ Logic Memory

### Phase 4: SOP è‡ªåŠ¨ç”Ÿæˆï¼ˆ6 ä¸ªæœˆï¼‰

**ç›®æ ‡**ï¼šä» Pattern è‡ªåŠ¨ç”Ÿæˆå¯æ‰§è¡Œçš„ SOP

**æ–¹æ¡ˆ**ï¼š
- Pattern â†’ Workflow DSL è½¬æ¢
- ç»Ÿè®¡æœ€ä½³å®è·µæ¦‚ç‡åˆ†å¸ƒ
- ç”Ÿæˆå¯å¤ç”¨çš„ Workflow æ¨¡æ¿

### Phase 5: Memory RLï¼ˆ12 ä¸ªæœˆï¼‰

**ç›®æ ‡**ï¼šä½¿ç”¨å¼ºåŒ–å­¦ä¹ ä¼˜åŒ– Memory ç®¡ç†

**æ–¹æ¡ˆ**ï¼š
- RL æ¨¡å‹å†³ç­– Memory å†™å…¥/åˆ é™¤/åˆå¹¶
- å¥–åŠ±å‡½æ•°ï¼šä¿¡æ¯ä¿ç•™ç‡ã€æ£€ç´¢å‡†ç¡®ç‡
- åœ¨çº¿å­¦ä¹ å’Œç­–ç•¥æ›´æ–°

---

## åä¸€ã€æ€»ç»“

### ä¸ºä»€ä¹ˆè¿™ä¸ªè®¾è®¡åˆç†ï¼Ÿ

1. **é€šç”¨æ€§å¼º**ï¼šæ¡†æ¶å±‚æä¾›æœºåˆ¶ï¼Œåº”ç”¨å±‚å®šä¹‰ç­–ç•¥
2. **æœ€å°ä¾µå…¥**ï¼šé€šè¿‡ Middleware è‡ªåŠ¨å·¥ä½œï¼Œæ— éœ€æ‰‹åŠ¨è°ƒç”¨
3. **å¯æ‰©å±•æ€§**ï¼šæ”¯æŒè‡ªå®šä¹‰ PatternMatcherã€Storage Backend
4. **ç”Ÿäº§å°±ç»ª**ï¼šå®Œæ•´çš„ç›‘æ§ã€æµ‹è¯•ã€æ–‡æ¡£
5. **ä¸ç°æœ‰ Memory ç³»ç»Ÿåä½œ**ï¼šå¤ç”¨ Provenanceã€Consolidation

### æ ¸å¿ƒä»·å€¼

**"è®© AI Agent ä»ç»éªŒä¸­å­¦ä¹ "** - è¿™æ˜¯ä¼ ç»Ÿ Memory ç³»ç»Ÿï¼ˆä»…å­˜å‚¨çŸ¥è¯†ï¼‰æ— æ³•æä¾›çš„èƒ½åŠ›ã€‚Logic Memory è®© Agent èƒ½å¤Ÿï¼š
- è®°ä½ç”¨æˆ·çš„åå¥½å’Œä¹ æƒ¯
- ä»æˆåŠŸå’Œå¤±è´¥ä¸­å­¦ä¹ 
- è‡ªåŠ¨æ”¹è¿›è¡Œä¸ºç­–ç•¥
- å®ç°çœŸæ­£çš„ä¸ªæ€§åŒ–

### ä¸‹ä¸€æ­¥è¡ŒåŠ¨

1. âœ… **å®¡é˜…è®¡åˆ’**ï¼šç¡®è®¤æŠ€æœ¯æ–¹æ¡ˆå’Œæ—¶é—´çº¿
2. ğŸš€ **å¯åŠ¨ Week 1**ï¼šå®ç°æ ¸å¿ƒæ¡†æ¶ï¼ˆtypes, store, managerï¼‰
3. ğŸ“ **å®šæœŸåŒæ­¥**ï¼šæ¯å‘¨äº”åŒæ­¥è¿›åº¦å’Œåé¦ˆ
4. ğŸ¯ **4 å‘¨ç›®æ ‡**ï¼šå®Œæˆæ¡†æ¶ + YunJin é›†æˆï¼Œå‘å¸ƒ v0.1.0-beta

---

**è®¡åˆ’åˆ¶å®šæ—¶é—´**ï¼š2025-12-04  
**é¢„è®¡å®Œæˆæ—¶é—´**ï¼š2025-12-30ï¼ˆ4 å‘¨ï¼‰  
**ç½®ä¿¡åº¦**ï¼šé«˜ï¼ˆåŸºäº Aster SDK å’Œ YunJin çš„å®é™…ä»£ç åˆ†æï¼‰

