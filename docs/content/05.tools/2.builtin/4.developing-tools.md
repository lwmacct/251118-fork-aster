---
title: å·¥å…·å¼€å‘æŒ‡å—
description: ä»é›¶å¼€å§‹å¼€å‘é«˜è´¨é‡çš„ AI Agent å·¥å…·
navigation:
  icon: i-lucide-code
---

# å·¥å…·å¼€å‘æŒ‡å—

æœ¬æŒ‡å—ä»‹ç»å¦‚ä½•å¼€å‘é«˜è´¨é‡çš„ aster å·¥å…·ï¼ŒåŒ…æ‹¬åŸºç¡€æ¥å£å®ç°ã€é«˜çº§ç‰¹æ€§ï¼ˆå¦‚ InputExamplesï¼‰ä»¥åŠæœ€ä½³å®è·µã€‚

## ğŸ“ æ ¸å¿ƒæ¥å£

### Tool æ¥å£

æ¯ä¸ªå·¥å…·å¿…é¡»å®ç° `tools.Tool` æ¥å£ï¼š

```go
// pkg/tools/tool.go
type Tool interface {
    // Name è¿”å›å·¥å…·åç§°ï¼ˆå…¨å±€å”¯ä¸€ï¼‰
    Name() string

    // Description è¿”å›å·¥å…·æè¿°ï¼ˆä¾› LLM ç†è§£å·¥å…·ç”¨é€”ï¼‰
    Description() string

    // InputSchema è¿”å›è¾“å…¥å‚æ•°çš„ JSON Schema
    InputSchema() map[string]interface{}

    // Execute æ‰§è¡Œå·¥å…·é€»è¾‘
    Execute(ctx context.Context, input map[string]interface{}, tc *ToolContext) (interface{}, error)

    // Prompt è¿”å›é¢å¤–çš„æç¤ºä¿¡æ¯ï¼ˆå¯é€‰ï¼Œè¿”å›ç©ºå­—ç¬¦ä¸²è¡¨ç¤ºæ— é¢å¤–æç¤ºï¼‰
    Prompt() string
}
```

### ExampleableTool æ¥å£ï¼ˆå¯é€‰ï¼‰

å®ç°æ­¤æ¥å£å¯ä»¥ä¸ºå·¥å…·æä¾›ä½¿ç”¨ç¤ºä¾‹ï¼Œæ˜¾è‘—æå‡ LLM çš„å·¥å…·è°ƒç”¨å‡†ç¡®ç‡ï¼š

```go
// pkg/tools/example.go
type ExampleableTool interface {
    Tool
    // Examples è¿”å›å·¥å…·ä½¿ç”¨ç¤ºä¾‹åˆ—è¡¨
    Examples() []ToolExample
}

// ToolExample å®šä¹‰ä¸€ä¸ªå·¥å…·ä½¿ç”¨ç¤ºä¾‹
type ToolExample struct {
    Description string                 // ç¤ºä¾‹æè¿°
    Input       map[string]interface{} // è¾“å…¥å‚æ•°
    Output      interface{}            // æœŸæœ›è¾“å‡ºï¼ˆå¯é€‰ï¼‰
}
```

> **æ€§èƒ½æå‡**: æ ¹æ® Anthropic çš„æµ‹è¯•ï¼Œæä¾› InputExamples å¯ä»¥å°†å·¥å…·è°ƒç”¨å‡†ç¡®ç‡ä» 72% æå‡åˆ° 90%ã€‚

## ğŸš€ å¿«é€Ÿå¼€å§‹

### æ­¥éª¤ 1: åˆ›å»ºå·¥å…·ç»“æ„

```go
package mytools

import (
    "context"
    "fmt"

    "github.com/astercloud/aster/pkg/tools"
)

// CalculatorTool ç®€å•è®¡ç®—å™¨å·¥å…·
type CalculatorTool struct {
    precision int // å°æ•°ç²¾åº¦
}

// NewCalculatorTool å·¥å…·å·¥å‚å‡½æ•°
func NewCalculatorTool(config map[string]interface{}) (tools.Tool, error) {
    precision := 2 // é»˜è®¤ç²¾åº¦
    if p, ok := config["precision"].(int); ok {
        precision = p
    }
    return &CalculatorTool{precision: precision}, nil
}
```

### æ­¥éª¤ 2: å®ç° Tool æ¥å£

```go
func (t *CalculatorTool) Name() string {
    return "Calculator"
}

func (t *CalculatorTool) Description() string {
    return "Perform mathematical calculations. Supports basic operations: add, subtract, multiply, divide."
}

func (t *CalculatorTool) InputSchema() map[string]interface{} {
    return map[string]interface{}{
        "type": "object",
        "properties": map[string]interface{}{
            "operation": map[string]interface{}{
                "type":        "string",
                "enum":        []string{"add", "subtract", "multiply", "divide"},
                "description": "The operation to perform",
            },
            "a": map[string]interface{}{
                "type":        "number",
                "description": "First operand",
            },
            "b": map[string]interface{}{
                "type":        "number",
                "description": "Second operand",
            },
        },
        "required": []string{"operation", "a", "b"},
    }
}

func (t *CalculatorTool) Prompt() string {
    return "" // æ— é¢å¤–æç¤º
}

func (t *CalculatorTool) Execute(ctx context.Context, input map[string]interface{}, tc *tools.ToolContext) (interface{}, error) {
    // 1. è§£æå‚æ•°
    operation, ok := input["operation"].(string)
    if !ok {
        return nil, fmt.Errorf("operation must be a string")
    }

    a, ok := input["a"].(float64)
    if !ok {
        return nil, fmt.Errorf("a must be a number")
    }

    b, ok := input["b"].(float64)
    if !ok {
        return nil, fmt.Errorf("b must be a number")
    }

    // 2. æ‰§è¡Œè®¡ç®—
    var result float64
    switch operation {
    case "add":
        result = a + b
    case "subtract":
        result = a - b
    case "multiply":
        result = a * b
    case "divide":
        if b == 0 {
            return nil, fmt.Errorf("division by zero")
        }
        result = a / b
    default:
        return nil, fmt.Errorf("unknown operation: %s", operation)
    }

    // 3. è¿”å›ç»“æ„åŒ–ç»“æœ
    return map[string]interface{}{
        "operation": operation,
        "a":         a,
        "b":         b,
        "result":    result,
    }, nil
}
```

### æ­¥éª¤ 3: æ·»åŠ ä½¿ç”¨ç¤ºä¾‹ï¼ˆæ¨èï¼‰

å®ç° `ExampleableTool` æ¥å£æ¥æä¾›ä½¿ç”¨ç¤ºä¾‹ï¼š

```go
// Examples è¿”å›å·¥å…·ä½¿ç”¨ç¤ºä¾‹
func (t *CalculatorTool) Examples() []tools.ToolExample {
    return []tools.ToolExample{
        {
            Description: "Add two numbers",
            Input: map[string]interface{}{
                "operation": "add",
                "a":         10,
                "b":         5,
            },
            Output: map[string]interface{}{
                "operation": "add",
                "a":         10,
                "b":         5,
                "result":    15,
            },
        },
        {
            Description: "Divide with decimal result",
            Input: map[string]interface{}{
                "operation": "divide",
                "a":         7,
                "b":         3,
            },
            Output: map[string]interface{}{
                "operation": "divide",
                "a":         7,
                "b":         3,
                "result":    2.3333333333333335,
            },
        },
    }
}
```

### æ­¥éª¤ 4: æ³¨å†Œå·¥å…·

```go
package main

import (
    "github.com/astercloud/aster/pkg/tools"
    "your-project/mytools"
)

func main() {
    // åˆ›å»ºå·¥å…·æ³¨å†Œè¡¨
    toolRegistry := tools.NewRegistry()

    // æ³¨å†Œå·¥å…·
    toolRegistry.Register("Calculator", mytools.NewCalculatorTool)

    // åœ¨ Agent æ¨¡æ¿ä¸­å£°æ˜ä½¿ç”¨
    templateRegistry.Register(&types.AgentTemplateDefinition{
        ID:    "math-assistant",
        Tools: []interface{}{"Calculator"},
        // ...
    })
}
```

## ğŸ¨ InputExamples æœ€ä½³å®è·µ

### ä½•æ—¶ä½¿ç”¨ Examples

```mermaid
graph TB
    Start[å·¥å…·å¼€å‘] --> Q1{å‚æ•°æ˜¯å¦å¤æ‚?}
    Q1 -->|æ˜¯| Use[ä½¿ç”¨ Examples]
    Q1 -->|å¦| Q2{å‚æ•°æ ¼å¼æ˜¯å¦ç‰¹æ®Š?}
    Q2 -->|æ˜¯| Use
    Q2 -->|å¦| Q3{å·¥å…·è°ƒç”¨å®¹æ˜“å‡ºé”™?}
    Q3 -->|æ˜¯| Use
    Q3 -->|å¦| Skip[å¯ä»¥è·³è¿‡]

    Use --> E1[æä¾› 2-3 ä¸ªç¤ºä¾‹]
    E1 --> E2[è¦†ç›–å…¸å‹ç”¨ä¾‹]
    E2 --> E3[è¦†ç›–è¾¹ç•Œæƒ…å†µ]

    style Use fill:#10b981
    style Skip fill:#94a3b8
```

### ç¤ºä¾‹æ•°é‡å»ºè®®

| å·¥å…·å¤æ‚åº¦ | å»ºè®®ç¤ºä¾‹æ•° | è¯´æ˜ |
|-----------|----------|------|
| ç®€å•å·¥å…· | 1-2 ä¸ª | ä¸€ä¸ªå…¸å‹ç”¨ä¾‹å³å¯ |
| ä¸­ç­‰å¤æ‚ | 2-3 ä¸ª | è¦†ç›–ä¸»è¦åœºæ™¯ |
| å¤æ‚å·¥å…· | 3-5 ä¸ª | åŒ…å«è¾¹ç•Œæƒ…å†µ |

### ç¤ºä¾‹è´¨é‡è¦æ±‚

```go
// âœ… å¥½çš„ç¤ºä¾‹
func (t *MyTool) Examples() []tools.ToolExample {
    return []tools.ToolExample{
        {
            // æè¿°æ¸…æ™°è¯´æ˜ç”¨é€”
            Description: "Create a new user with email validation",
            Input: map[string]interface{}{
                // ä½¿ç”¨çœŸå®ã€æœ‰æ„ä¹‰çš„å€¼
                "name":  "Alice Johnson",
                "email": "alice@example.com",
                "role":  "admin",
            },
            // æä¾›å®Œæ•´çš„è¾“å‡ºæ ¼å¼
            Output: map[string]interface{}{
                "id":         "usr_abc123",
                "name":       "Alice Johnson",
                "email":      "alice@example.com",
                "role":       "admin",
                "created_at": "2024-01-15T10:30:00Z",
            },
        },
    }
}

// âŒ ä¸å¥½çš„ç¤ºä¾‹
func (t *BadTool) Examples() []tools.ToolExample {
    return []tools.ToolExample{
        {
            Description: "test",           // æè¿°ä¸æ¸…æ™°
            Input: map[string]interface{}{
                "x": "foo",                // å‚æ•°åä¸æ¸…æ™°
                "y": 123,                  // å€¼æ²¡æœ‰å®é™…æ„ä¹‰
            },
            // ç¼ºå°‘ Output
        },
    }
}
```

## ğŸ“‹ å®Œæ•´å·¥å…·æ¨¡æ¿

ä»¥ä¸‹æ˜¯ä¸€ä¸ªåŠŸèƒ½å®Œæ•´çš„å·¥å…·å®ç°æ¨¡æ¿ï¼š

```go
package mytools

import (
    "context"
    "fmt"
    "time"

    "github.com/astercloud/aster/pkg/tools"
)

// MyTool å·¥å…·æè¿°
type MyTool struct {
    config MyToolConfig
}

type MyToolConfig struct {
    Timeout   time.Duration
    MaxRetry  int
    APIKey    string
}

// NewMyTool åˆ›å»ºå·¥å…·å®ä¾‹
func NewMyTool(config map[string]interface{}) (tools.Tool, error) {
    // 1. è§£æå¹¶éªŒè¯é…ç½®
    timeout := 30 * time.Second
    if t, ok := config["timeout"].(int); ok {
        timeout = time.Duration(t) * time.Second
    }

    maxRetry := 3
    if r, ok := config["max_retry"].(int); ok {
        maxRetry = r
    }

    apiKey, ok := config["api_key"].(string)
    if !ok || apiKey == "" {
        return nil, fmt.Errorf("api_key is required")
    }

    return &MyTool{
        config: MyToolConfig{
            Timeout:  timeout,
            MaxRetry: maxRetry,
            APIKey:   apiKey,
        },
    }, nil
}

// Name å·¥å…·åç§°
func (t *MyTool) Name() string {
    return "MyTool"
}

// Description å·¥å…·æè¿°
func (t *MyTool) Description() string {
    return `Detailed description of what the tool does.

Key features:
- Feature 1
- Feature 2
- Feature 3

Use this tool when you need to...`
}

// InputSchema è¾“å…¥å‚æ•° Schema
func (t *MyTool) InputSchema() map[string]interface{} {
    return map[string]interface{}{
        "type": "object",
        "properties": map[string]interface{}{
            "required_param": map[string]interface{}{
                "type":        "string",
                "description": "A required parameter",
            },
            "optional_param": map[string]interface{}{
                "type":        "integer",
                "description": "An optional parameter with default value",
                "default":     10,
            },
            "enum_param": map[string]interface{}{
                "type":        "string",
                "enum":        []string{"option1", "option2", "option3"},
                "description": "Choose one of the available options",
            },
        },
        "required": []string{"required_param"},
    }
}

// Prompt é¢å¤–æç¤ºä¿¡æ¯
func (t *MyTool) Prompt() string {
    return `Additional guidance for using this tool:
- Always provide required_param
- Use option1 for most cases
- Check the output format before proceeding`
}

// Execute æ‰§è¡Œå·¥å…·
func (t *MyTool) Execute(ctx context.Context, input map[string]interface{}, tc *tools.ToolContext) (interface{}, error) {
    // 1. å‚æ•°éªŒè¯
    requiredParam, ok := input["required_param"].(string)
    if !ok {
        return nil, fmt.Errorf("required_param must be a string")
    }

    optionalParam := 10 // é»˜è®¤å€¼
    if v, ok := input["optional_param"].(float64); ok {
        optionalParam = int(v)
    }

    // 2. ä¸Šä¸‹æ–‡æ£€æŸ¥
    select {
    case <-ctx.Done():
        return nil, ctx.Err()
    default:
    }

    // 3. æ‰§è¡Œä¸šåŠ¡é€»è¾‘
    result, err := t.doWork(ctx, requiredParam, optionalParam)
    if err != nil {
        return nil, fmt.Errorf("failed to execute: %w", err)
    }

    // 4. è¿”å›ç»“æ„åŒ–ç»“æœ
    return map[string]interface{}{
        "success":   true,
        "data":      result,
        "timestamp": time.Now().Format(time.RFC3339),
    }, nil
}

// Examples ä½¿ç”¨ç¤ºä¾‹ï¼ˆå®ç° ExampleableTool æ¥å£ï¼‰
func (t *MyTool) Examples() []tools.ToolExample {
    return []tools.ToolExample{
        {
            Description: "Basic usage with required parameter only",
            Input: map[string]interface{}{
                "required_param": "example_value",
            },
            Output: map[string]interface{}{
                "success":   true,
                "data":      "processed: example_value",
                "timestamp": "2024-01-15T10:30:00Z",
            },
        },
        {
            Description: "Full usage with all parameters",
            Input: map[string]interface{}{
                "required_param": "example_value",
                "optional_param": 20,
                "enum_param":     "option2",
            },
            Output: map[string]interface{}{
                "success":   true,
                "data":      "processed: example_value (option2, limit: 20)",
                "timestamp": "2024-01-15T10:30:00Z",
            },
        },
    }
}

// doWork å†…éƒ¨ä¸šåŠ¡é€»è¾‘
func (t *MyTool) doWork(ctx context.Context, param string, limit int) (string, error) {
    // å®ç°å…·ä½“ä¸šåŠ¡é€»è¾‘
    return fmt.Sprintf("processed: %s (limit: %d)", param, limit), nil
}
```

## ğŸ§ª æµ‹è¯•å·¥å…·

### å•å…ƒæµ‹è¯•æ¨¡æ¿

```go
package mytools_test

import (
    "context"
    "testing"

    "github.com/astercloud/aster/pkg/tools"
    "your-project/mytools"
)

func TestMyTool_Execute(t *testing.T) {
    // 1. åˆ›å»ºå·¥å…·
    tool, err := mytools.NewMyTool(map[string]interface{}{
        "api_key": "test-key",
    })
    if err != nil {
        t.Fatalf("Failed to create tool: %v", err)
    }

    // 2. å‡†å¤‡æµ‹è¯•ç”¨ä¾‹
    tests := []struct {
        name    string
        input   map[string]interface{}
        wantErr bool
    }{
        {
            name: "valid input",
            input: map[string]interface{}{
                "required_param": "test",
            },
            wantErr: false,
        },
        {
            name:    "missing required param",
            input:   map[string]interface{}{},
            wantErr: true,
        },
        {
            name: "invalid param type",
            input: map[string]interface{}{
                "required_param": 123, // åº”è¯¥æ˜¯ string
            },
            wantErr: true,
        },
    }

    // 3. æ‰§è¡Œæµ‹è¯•
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            ctx := context.Background()
            tc := &tools.ToolContext{}

            result, err := tool.Execute(ctx, tt.input, tc)

            if tt.wantErr && err == nil {
                t.Error("expected error, got nil")
            }
            if !tt.wantErr && err != nil {
                t.Errorf("unexpected error: %v", err)
            }
            if !tt.wantErr && result == nil {
                t.Error("expected result, got nil")
            }
        })
    }
}

func TestMyTool_Examples(t *testing.T) {
    tool, _ := mytools.NewMyTool(map[string]interface{}{
        "api_key": "test-key",
    })

    // æ£€æŸ¥æ˜¯å¦å®ç°äº† ExampleableTool æ¥å£
    exampleTool, ok := tool.(tools.ExampleableTool)
    if !ok {
        t.Skip("Tool does not implement ExampleableTool")
    }

    examples := exampleTool.Examples()
    if len(examples) == 0 {
        t.Error("expected at least one example")
    }

    // éªŒè¯æ¯ä¸ªç¤ºä¾‹éƒ½å¯ä»¥æˆåŠŸæ‰§è¡Œ
    ctx := context.Background()
    tc := &tools.ToolContext{}

    for i, ex := range examples {
        t.Run(ex.Description, func(t *testing.T) {
            _, err := tool.Execute(ctx, ex.Input, tc)
            if err != nil {
                t.Errorf("example %d failed: %v", i, err)
            }
        })
    }
}
```

## âœ… å¼€å‘æ£€æŸ¥æ¸…å•

å¼€å‘å·¥å…·æ—¶ï¼Œè¯·ç¡®ä¿æ»¡è¶³ä»¥ä¸‹è¦æ±‚ï¼š

### åŸºç¡€è¦æ±‚

- [ ] å·¥å…·åç§°å”¯ä¸€ä¸”æœ‰æ„ä¹‰
- [ ] Description æ¸…æ™°æè¿°å·¥å…·ç”¨é€”
- [ ] InputSchema å®Œæ•´å®šä¹‰æ‰€æœ‰å‚æ•°
- [ ] æ‰€æœ‰å¿…éœ€å‚æ•°æ ‡è®°åœ¨ `required` ä¸­
- [ ] Execute æ­£ç¡®å¤„ç†æ‰€æœ‰å‚æ•°ç±»å‹

### é”™è¯¯å¤„ç†

- [ ] éªŒè¯æ‰€æœ‰è¾“å…¥å‚æ•°
- [ ] å¤„ç†å‚æ•°ç±»å‹é”™è¯¯
- [ ] å¤„ç†ä¸šåŠ¡é€»è¾‘é”™è¯¯
- [ ] ä½¿ç”¨ `fmt.Errorf` åŒ…è£…é”™è¯¯ï¼Œæä¾›ä¸Šä¸‹æ–‡
- [ ] æ£€æŸ¥ context å–æ¶ˆ

### è¿”å›å€¼

- [ ] è¿”å›ç»“æ„åŒ–æ•°æ®ï¼ˆmap æˆ– structï¼‰
- [ ] åŒ…å«è¶³å¤Ÿçš„ä¿¡æ¯ä¾› LLM ç†è§£
- [ ] é”™è¯¯æ—¶è¿”å›æœ‰ç”¨çš„é”™è¯¯ä¿¡æ¯

### Examplesï¼ˆæ¨èï¼‰

- [ ] æä¾› 2-3 ä¸ªå…¸å‹ä½¿ç”¨ç¤ºä¾‹
- [ ] ç¤ºä¾‹æè¿°æ¸…æ™°æ˜äº†
- [ ] ç¤ºä¾‹è¾“å…¥å€¼çœŸå®æœ‰æ„ä¹‰
- [ ] ç¤ºä¾‹è¾“å‡ºä¸å®é™…ä¸€è‡´

### æµ‹è¯•

- [ ] å•å…ƒæµ‹è¯•è¦†ç›–ä¸»è¦åœºæ™¯
- [ ] æµ‹è¯•å‚æ•°éªŒè¯
- [ ] æµ‹è¯•é”™è¯¯å¤„ç†
- [ ] æµ‹è¯• Examples å¯æ‰§è¡Œ

## ğŸ”— ç›¸å…³èµ„æº

- [å†…ç½®å·¥å…·å‚è€ƒ](./1.builtin.md) - æŸ¥çœ‹å†…ç½®å·¥å…·å®ç°
- [è‡ªå®šä¹‰å·¥å…·](./3.custom.md) - æ›´å¤šè‡ªå®šä¹‰å·¥å…·ç¤ºä¾‹
- [MCP é›†æˆ](../3.mcp/overview.md) - é›†æˆå¤–éƒ¨å·¥å…·
- [Tool æ¥å£ API](/api-reference/tools) - å®Œæ•´ API æ–‡æ¡£
